[{"title":"","content":"大家好，我用mongoose查询数据，但用find命令，每次都会查询出_ID字段，而我不需要这个字段，请问如何不查询这个字段。    exports.fetchProvince = function (callback) {        var options = {sort: 'id'};        Province.find({}, 'id name', options, callback);    };"},{"title":"","content":""},{"title":"","content":""},{"title":"","content":""},{"title":"","content":"今天学习express的时候发现安装了express模块但是死活不能使用express命令，在windows上提示内部或者外部命令。在Linux上也不能使用，类似的错误信息。在网上找到了解决方案，记录如下：\n版本问题，安装的时候使用命令： npm install -g express@3.5.0   即可解决问题\n刚学习node.js，不知道问题的根源是什么？希望知道的大虾解析一下，拜谢。。。。"},{"title":"","content":"一场专注于 JavaScript 和 Node.js 技术，为期两天的国际性技术大会。届时，大会会邀请国内外的优秀讲师为大家分享在 JavaScript 和 Node.js 技术方面的经验。\n时间会场均已确定：将于 2014-6-21 ~ 2014-6-22(周六, 周日) 在 杭州希尔顿酒店 和各位 JavaScript 开发者见面。\n具体细节请访问我们的官网：http://t.cn/8s9SHzw\n也欢迎各位扫面下面的微信二维码关注我们来获取大会最新进展（还有抽奖机会哦）！"},{"title":"","content":"今天学习express的时候发现安装了express模块但是死活不能使用express命令，在windows上提示内部或者外部命令。在Linux上也不能使用，类似的错误信息。在网上找到了解决方案，记录如下：\n版本问题，安装的时候使用命令： npm install -g express@3.5.0   即可解决问题\n刚学习node.js，不知道问题的根源是什么？希望知道的大虾解析一下，拜谢。。。。"},{"title":"","content":""},{"title":"","content":"大家好，我用mongoose查询数据，但用find命令，每次都会查询出_ID字段，而我不需要这个字段，请问如何不查询这个字段。    exports.fetchProvince = function (callback) {        var options = {sort: 'id'};        Province.find({}, 'id name', options, callback);    };"},{"title":"","content":"nodejs有没有支持异步查询的模板?nodejs有没有支持异步查询的模板？例如：可以在模板里这样写，User.find(id,function(){//..........});\n或者var userlist = User.findAll()"},{"title":"","content":""},{"title":"","content":""},{"title":"","content":"在cnodejs上看得比较多的主要是安装、配置、框架集成等话题。很少谈及js语言本身的讨论，今天我来起个头，希望大家能积极参与，碰撞出一些火花。\n出处\njs的出处大家都知道，先是netscape给自己浏览器写的，后来标准化了，集成到ECMA标准集中，成为ECMAScript 262标准，后来伴随html5制定了265版本。师出同门的还有flex 所用的action script, 和photoshop所用的脚本，最近还听说有些硬件也用上了js。所以，大家今后其实还可以到这些领域去施展一下拳脚。\njs起什么作用？\njs 首先是一种计算机语言，其最核心的功能是：\n\n按逻辑执行程序\n操控数据\n输入/输出\n\n其次才是它的语法特性(比如OOP)、执行特性(比如异步)、易用性(比如自动内存管理)。就其核心功能而言，js跟其它任何一门语言都无差别。\njs的哪些特性是专为浏览器设计的？\njs在浏览器中的运行，运行环境上下文是由浏览器程序赋予的，即window对象。因此，浏览器中运行时，this即是指window。js对浏览器的主要用途有二：\n\n实现DOM标准。如构造及保存节点树、提供访问和操控方法、响应节点事件(mouseOver, click...)\n与浏览器环境交互。如与窗口对象(Window)、Location、History、Navigator、Screen交互\n\n上面第1点中的事件问题一定要注意。我也是直到今天才知道这是DOM标准的一部分，而javascript当初为了实现这个标准，将响应事件的的能力内化在了语言中。也就成了后来大家所津津乐道的一大特性。其实，任何一种需要操控UI的语言都需要具备这种能力，或者通过别的方法变相实现这种能力(比如线程)。而那些不需要处理UI的语言就没怎么考虑过这个问题，如php, ruby, python, java，这些语言对事件的响应几乎都是通过线程实现。但javascript是单线程的，无法启动新线程，因此事件就成了变相多线程方式。\n移植到浏览器以外的环境执行需要具备什么条件？\n我以前不知道浏览器有webkit和V8的时候，以为浏览器是一个整体性的，不可分割的软件。知道后，才发现原来浏览器内UI元素的管理和程序执行环境是分别由不同的引擎在支撑。既然程序由专门的引擎(虚拟机)在支撑，那这个虚拟机就可以移出来。但是，脱离了浏览器的环境，移出来做什么呢？当然是做些常规程序做的事情：像perl一样做系统管理脚本，或是像php/java那样做服务器，或者像C一样无所不能。\n\n但既然移出来到操作系统所提供的环境运行，那程序本身的存储方式很大可能性就是文件，因此，操作文件的功能也必不可少。既然可以操作程序源文件或执行文件，那普通文件也自然不在话下，很多文件可以用来做为数据源或存储结果。\n进一步考虑文件操作。文件如何读入？读入后如何存储？无论是源代码这样的ASCII字符还是图片、视频、word文档这种非ASCII数据，要读进来，就需要具备Read()方法，存起来就需要Write()方法。而文件读写肯定不能一个字节一个字节的操作，所以，还需要有二进制数据的容器，Buffer就是干这个的。考虑到不同的CPU和操作系统，以及网络传输规范等情况，还需要对大端序和小端序的支持。\n要做服务器，那就必须能够打开一个网络端口进行监听。因此，网络操作能力也需要具备，其实这也就是扩展一个跟操作系统间的接口而已。这在浏览器上也是可以的，但是没必要。\n进一步考虑网络操作，网络不能向磁盘一样预先知道其确切的传输量。而是一个数据流，因此，需要一个流式的读写方法。\njs虽然是可响应事件的，但事件是为DOM设计的，比如绑定对象必须是DOM节点(非HTML)，事件会向父节点传递(冒泡)。对于更为常规的编程，不需要这样的事件机制，并且需要脱离DOM规范的设计。因此，需要实现一个额外的事件管理器。这就是NodeJs中的Event Class。\n有时需要调用那些成熟软件，就需要跟安装在操作系统上的其它程序交互，通过在操作系统提供的shell环境，发起shell指令调用其它程序。这就是NodeJs中OS模块的作用。\n\n总结一下，需要移出来到操作系统的大环境中运行，需要以下特性：\n\n文件操作\n流式读写\n二进制数据容器\n网络操作\nEvent Class\nshell交互\n\n如何操控DOM以外的对象？\n\n网络：\n数据库：\nphotoshop图层：\n文件：\n二进制数据：\n声音：\n串口：\nUSB设备：\n\n总结：\n无论哪种，它们都只是一个IO对象，这些对象都是二进制数据，或者是二进制数据驱动的。所以只要你能控制这些二进制数据，并能读取或写入到对应的地址或设备里去，那就可以操控它。对js而言，涉及两个问题：\n\n二进制数据的操纵需要语言本身支持(其实几乎所有语言都支持二进制数据的，但js本身恰恰并未支持，所以NodeJs一上来就先解决了这个问题);\n地址和设备的读写控制由操作系统管理，所以要额外添加一些接口来跟操作系统沟通。这也是NodeJs需要一个标准库的原因。\n\n补充问题\n\n标准库没涉及到的对象怎么办？比如遥控飞机、控制门锁、蓝牙通信、各类传感器数据获取等。这些设备的控制在标准库中没有，但属于操作系统可控的范围，因此，只要补充对应的操作库即可。这就是NodeJs留有C++接口的原因。\n那些操作系统管不了的事情怎么办？比如photoshop图层、画笔、flex中的元素、动画等等。这些属于应用层之上的对象，就需要应用自己创建一个执行环境，并赋予执行上下文，定义各类对象和执行逻辑。这样就可以了。\n\n跟其他语言有什么异同？\n从最底层的运行逻辑上讲，js跟其它语言没有什么差异，都是以逻辑结构做为执行条件。从执行环境层面来说，各种语言的执行顺序略有不同，有的语言是以顺序运行，有的靠触发，但根本上都是顺序执行的，只是执行的范围有所不同。因此，其执行是严格可预测的，而不能预测的只是事件发生的时间。\n对JS应用的展望\njs可以在浏览器上执行，也可以在服务器上执行，这是大家已经看到的。但其实它做为一种常规语言，可以做几乎任何事：\n\n做系统管理脚本。\n做普通GUI程序的控制语言。这需要扩展绘图模块，并在应用程序中集成js引擎。实际上现在linux上有个项目(Seed)就已经实现了，其图形库是GTK，控制语言使用javascript。\n做Android, ios平台上的普通app。实际上现在的phoneGap(Cordova)就是将webkit+js引擎预先集成到app中，开发者仅需像开发web一样开发即可。但这种app需要每个都集成一个webkit+v8(或其它js引擎)。更好的方式是整个大环境就是一个webkit+v8，然后每个app就只有相应的html, css, js代码即可，firefoxOS既是如此。要做手机app，则需要js引擎补充实现各种设备访问接口。如拨号、3D传感器、摄像头、GPS、蓝牙等。\n在带操作系统的微型PC上运行。比如前面帖子中有人编译到了openWRT上；还有一个控制auduino的NodeJs模块(名叫Johnny-Five)\n其它IO密集，但处理时效性要求高的领域里\n但也有例外，js也有不能做的事情：\n单片机程序，或者实现一个裸机操作系统。因为js必须要一个虚拟机来运行，而虚拟机本身还不具备操作系统的功能。如设备管理、内存管理(这里可不是指自动垃圾回收机制，而是真正的物理内存)、任务调度(当然，单一功能的设备上，单线程的js无需理会这个需求)。\n科学计算。(这个不知道我说的对不对，求指正)\n\n\n\n由于时间有限，暂时写这么多。有空再补！也欢迎大家留言交流！"},{"title":"","content":"在cnodejs上看得比较多的主要是安装、配置、框架集成等话题。很少谈及js语言本身的讨论，今天我来起个头，希望大家能积极参与，碰撞出一些火花。\n出处\njs的出处大家都知道，先是netscape给自己浏览器写的，后来标准化了，集成到ECMA标准集中，成为ECMAScript 262标准，后来伴随html5制定了265版本。师出同门的还有flex 所用的action script, 和photoshop所用的脚本，最近还听说有些硬件也用上了js。所以，大家今后其实还可以到这些领域去施展一下拳脚。\njs起什么作用？\njs 首先是一种计算机语言，其最核心的功能是：\n\n按逻辑执行程序\n操控数据\n输入/输出\n\n其次才是它的语法特性(比如OOP)、执行特性(比如异步)、易用性(比如自动内存管理)。就其核心功能而言，js跟其它任何一门语言都无差别。\njs的哪些特性是专为浏览器设计的？\njs在浏览器中的运行，运行环境上下文是由浏览器程序赋予的，即window对象。因此，浏览器中运行时，this即是指window。js对浏览器的主要用途有二：\n\n实现DOM标准。如构造及保存节点树、提供访问和操控方法、响应节点事件(mouseOver, click...)\n与浏览器环境交互。如与窗口对象(Window)、Location、History、Navigator、Screen交互\n\n上面第1点中的事件问题一定要注意。我也是直到今天才知道这是DOM标准的一部分，而javascript当初为了实现这个标准，将响应事件的的能力内化在了语言中。也就成了后来大家所津津乐道的一大特性。其实，任何一种需要操控UI的语言都需要具备这种能力，或者通过别的方法变相实现这种能力(比如线程)。而那些不需要处理UI的语言就没怎么考虑过这个问题，如php, ruby, python, java，这些语言对事件的响应几乎都是通过线程实现。但javascript是单线程的，无法启动新线程，因此事件就成了变相多线程方式。\n移植到浏览器以外的环境执行需要具备什么条件？\n我以前不知道浏览器有webkit和V8的时候，以为浏览器是一个整体性的，不可分割的软件。知道后，才发现原来浏览器内UI元素的管理和程序执行环境是分别由不同的引擎在支撑。既然程序由专门的引擎(虚拟机)在支撑，那这个虚拟机就可以移出来。但是，脱离了浏览器的环境，移出来做什么呢？当然是做些常规程序做的事情：像perl一样做系统管理脚本，或是像php/java那样做服务器，或者像C一样无所不能。\n\n但既然移出来到操作系统所提供的环境运行，那程序本身的存储方式很大可能性就是文件，因此，操作文件的功能也必不可少。既然可以操作程序源文件或执行文件，那普通文件也自然不在话下，很多文件可以用来做为数据源或存储结果。\n进一步考虑文件操作。文件如何读入？读入后如何存储？无论是源代码这样的ASCII字符还是图片、视频、word文档这种非ASCII数据，要读进来，就需要具备Read()方法，存起来就需要Write()方法。而文件读写肯定不能一个字节一个字节的操作，所以，还需要有二进制数据的容器，Buffer就是干这个的。考虑到不同的CPU和操作系统，以及网络传输规范等情况，还需要对大端序和小端序的支持。\n要做服务器，那就必须能够打开一个网络端口进行监听。因此，网络操作能力也需要具备，其实这也就是扩展一个跟操作系统间的接口而已。这在浏览器上也是可以的，但是没必要。\n进一步考虑网络操作，网络不能向磁盘一样预先知道其确切的传输量。而是一个数据流，因此，需要一个流式的读写方法。\njs虽然是可响应事件的，但事件是为DOM设计的，比如绑定对象必须是DOM节点(非HTML)，事件会向父节点传递(冒泡)。对于更为常规的编程，不需要这样的事件机制，并且需要脱离DOM规范的设计。因此，需要实现一个额外的事件管理器。这就是NodeJs中的Event Class。\n有时需要调用那些成熟软件，就需要跟安装在操作系统上的其它程序交互，通过在操作系统提供的shell环境，发起shell指令调用其它程序。这就是NodeJs中OS模块的作用。\n\n总结一下，需要移出来到操作系统的大环境中运行，需要以下特性：\n\n文件操作\n流式读写\n二进制数据容器\n网络操作\nEvent Class\nshell交互\n\n如何操控DOM以外的对象？\n\n网络：\n数据库：\nphotoshop图层：\n文件：\n二进制数据：\n声音：\n串口：\nUSB设备：\n\n总结：\n无论哪种，它们都只是一个IO对象，这些对象都是二进制数据，或者是二进制数据驱动的。所以只要你能控制这些二进制数据，并能读取或写入到对应的地址或设备里去，那就可以操控它。对js而言，涉及两个问题：\n\n二进制数据的操纵需要语言本身支持(其实几乎所有语言都支持二进制数据的，但js本身恰恰并未支持，所以NodeJs一上来就先解决了这个问题);\n地址和设备的读写控制由操作系统管理，所以要额外添加一些接口来跟操作系统沟通。这也是NodeJs需要一个标准库的原因。\n\n补充问题\n\n标准库没涉及到的对象怎么办？比如遥控飞机、控制门锁、蓝牙通信、各类传感器数据获取等。这些设备的控制在标准库中没有，但属于操作系统可控的范围，因此，只要补充对应的操作库即可。这就是NodeJs留有C++接口的原因。\n那些操作系统管不了的事情怎么办？比如photoshop图层、画笔、flex中的元素、动画等等。这些属于应用层之上的对象，就需要应用自己创建一个执行环境，并赋予执行上下文，定义各类对象和执行逻辑。这样就可以了。\n\n跟其他语言有什么异同？\n从最底层的运行逻辑上讲，js跟其它语言没有什么差异，都是以逻辑结构做为执行条件。从执行环境层面来说，各种语言的执行顺序略有不同，有的语言是以顺序运行，有的靠触发，但根本上都是顺序执行的，只是执行的范围有所不同。因此，其执行是严格可预测的，而不能预测的只是事件发生的时间。\n对JS应用的展望\njs可以在浏览器上执行，也可以在服务器上执行，这是大家已经看到的。但其实它做为一种常规语言，可以做几乎任何事：\n\n做系统管理脚本。\n做普通GUI程序的控制语言。这需要扩展绘图模块，并在应用程序中集成js引擎。实际上现在linux上有个项目(Seed)就已经实现了，其图形库是GTK，控制语言使用javascript。\n做Android, ios平台上的普通app。实际上现在的phoneGap(Cordova)就是将webkit+js引擎预先集成到app中，开发者仅需像开发web一样开发即可。但这种app需要每个都集成一个webkit+v8(或其它js引擎)。更好的方式是整个大环境就是一个webkit+v8，然后每个app就只有相应的html, css, js代码即可，firefoxOS既是如此。要做手机app，则需要js引擎补充实现各种设备访问接口。如拨号、3D传感器、摄像头、GPS、蓝牙等。\n在带操作系统的微型PC上运行。比如前面帖子中有人编译到了openWRT上；还有一个控制auduino的NodeJs模块(名叫Johnny-Five)\n其它IO密集，但处理时效性要求高的领域里\n但也有例外，js也有不能做的事情：\n单片机程序，或者实现一个裸机操作系统。因为js必须要一个虚拟机来运行，而虚拟机本身还不具备操作系统的功能。如设备管理、内存管理(这里可不是指自动垃圾回收机制，而是真正的物理内存)、任务调度(当然，单一功能的设备上，单线程的js无需理会这个需求)。\n科学计算。(这个不知道我说的对不对，求指正)\n\n\n\n由于时间有限，暂时写这么多。有空再补！也欢迎大家留言交流！"},{"title":"","content":"github地址: koa-router-namespace复制下大致的用法，详细说明请见上面的地址。\napp.namespace('/users', function() {\n    // 匹配 GET /users\n    app.get('/', function *() {\n\n    })\n\n    // path为/时可省略，直接传handler即可\n    // 匹配 POST /users\n    app.post(function *() {\n\n    })\n\n    // 匹配 GET /users/:id\n    app.get('/:id', function *() {\n\n    })\n\n    // 匹配 DELETE /users/:id\n    app.del('/:id', function *() {\n\n    })\n\n    // 匹配 PUT /users/:id\n    app.put('/:id', function *() {\n\n    })\n\n    // 支持嵌套\n    app.namespace('/:id', function() {\n        // 匹配 GET /users/:id/contacts\n        app.get('/contacts', function *() {\n\n        })\n    })\n\n    // route method支持数组,这个本身koa-router也是支持的，只是我看他文档没好像没写\n    // namespace不支持数组\n    // 匹配 GET /users/:id 和 GET /users/:id/profile\n    app.get(['/:id', '/:id/profile'], function *() {\n\n    })\n})"},{"title":"","content":"这几天把自己收集了几年的纯音乐整理了下，做了个简单的SPA托到 GitHub Pages 了。无私奉献下~扣腚累了听听纯音乐放松放松。模版来自 网友Null。\nhttp://nswbmw.github.io/maitian/"},{"title":"","content":"github地址: koa-router-namespace复制下大致的用法，详细说明请见上面的地址。\napp.namespace('/users', function() {\n    // 匹配 GET /users\n    app.get('/', function *() {\n\n    })\n\n    // path为/时可省略，直接传handler即可\n    // 匹配 POST /users\n    app.post(function *() {\n\n    })\n\n    // 匹配 GET /users/:id\n    app.get('/:id', function *() {\n\n    })\n\n    // 匹配 DELETE /users/:id\n    app.del('/:id', function *() {\n\n    })\n\n    // 匹配 PUT /users/:id\n    app.put('/:id', function *() {\n\n    })\n\n    // 支持嵌套\n    app.namespace('/:id', function() {\n        // 匹配 GET /users/:id/contacts\n        app.get('/contacts', function *() {\n\n        })\n    })\n\n    // route method支持数组,这个本身koa-router也是支持的，只是我看他文档没好像没写\n    // namespace不支持数组\n    // 匹配 GET /users/:id 和 GET /users/:id/profile\n    app.get(['/:id', '/:id/profile'], function *() {\n\n    })\n})"},{"title":"","content":"这几天把自己收集了几年的纯音乐整理了下，做了个简单的SPA托到 GitHub Pages 了。无私奉献下~扣腚累了听听纯音乐放松放松。模版来自 网友Null。\nhttp://nswbmw.github.io/maitian/"},{"title":"","content":"模块叫 sync-runner。今天刚写的，要睡了也懒得换系统再写个，所以暂时只支持windows，不过其它系统也是要写的。\n大致就是可以这样：\nvar run = require(\"sync-runner\");\nvar result = run(\"ping 127.0.0.1\", 1000);\nconsole.log(result);不推荐将这个模块用于服务器，可以用于本地的 REPL 程序以及 native app 如 node-webkit 等。\n比如要通过node来调用gcc编译器啊，然后再比如获取系统gcc版本啊，就可以用它方便地使用了：\nvar result = run(\"gcc --version\");安装很简单：\n$ npm install sync-runnergithub的repo在https://github.com/XadillaX/syncRunner\n欢迎大家fork或者干嘛干嘛，也欢迎大家提交别的系统的同步函数-。 - 在我还没写之前。\n或者找找bug什么的，谢谢啦 0. 0"},{"title":"","content":""},{"title":"","content":"模块叫 sync-runner。今天刚写的，要睡了也懒得换系统再写个，所以暂时只支持windows，不过其它系统也是要写的。\n大致就是可以这样：\nvar run = require(\"sync-runner\");\nvar result = run(\"ping 127.0.0.1\", 1000);\nconsole.log(result);不推荐将这个模块用于服务器，可以用于本地的 REPL 程序以及 native app 如 node-webkit 等。\n比如要通过node来调用gcc编译器啊，然后再比如获取系统gcc版本啊，就可以用它方便地使用了：\nvar result = run(\"gcc --version\");安装很简单：\n$ npm install sync-runnergithub的repo在https://github.com/XadillaX/syncRunner\n欢迎大家fork或者干嘛干嘛，也欢迎大家提交别的系统的同步函数-。 - 在我还没写之前。\n或者找找bug什么的，谢谢啦 0. 0"},{"title":"","content":"nodejs有没有支持异步查询的模板?nodejs有没有支持异步查询的模板？例如：可以在模板里这样写，User.find(id,function(){//..........});\n或者var userlist = User.findAll()"},{"title":"","content":""},{"title":"","content":"一场专注于 JavaScript 和 Node.js 技术，为期两天的国际性技术大会。届时，大会会邀请国内外的优秀讲师为大家分享在 JavaScript 和 Node.js 技术方面的经验。\n时间会场均已确定：将于 2014-6-21 ~ 2014-6-22(周六, 周日) 在 杭州希尔顿酒店 和各位 JavaScript 开发者见面。\n具体细节请访问我们的官网：http://t.cn/8s9SHzw\n也欢迎各位扫面下面的微信二维码关注我们来获取大会最新进展（还有抽奖机会哦）！"},{"title":"","content":""},{"title":"","content":"平时爱看知乎日报，写了个最简单的 知乎日报 web版，放在了JAE(http://zhihudaily.jd-app.com)代码如下：\n\n2014.04.13更新：增加了 前一天 功能，移动设备界面适配，采用巧妙的方式规避了时间格式化问题（取消注释即可下载所有历史文件）\n\nvar http = require('http');\nvar fs = require('fs');\nvar date = '';\nfunction fetchBefore(beforeDate) {\n    http.get(\"http://news.at.zhihu.com/api/1.2/news/before/\" + beforeDate, function (res) {\n        if (res.statusCode != 200) return;\n        var data = '';\n        res.setEncoding('utf8');\n        res.on('data', function (chunk) {\n            data += chunk;\n        });\n        res.on('end', function () {\n            var year = beforeDate.substr(0, 4);\n            if (!fs.existsSync(year))    fs.mkdirSync(year);\n            fs.writeFile(year + '/' + beforeDate + '.json', data);\n            //if (beforeDate != '20130520') fetchBefore(JSON.parse(data).date);  //fetch all the history stories\n        });\n    });\n}\n(function fetchLatest() {\n    http.get(\"http://news.at.zhihu.com/api/1.2/news/latest\", function (res) {\n        if (res.statusCode != 200) return;\n        var data = '';\n        res.setEncoding('utf8');\n        res.on('data', function (chunk) {\n            data += chunk;\n        });\n        res.on('end', function () {\n            var json = JSON.parse(data);\n            if (date != json.date) {\n                date = json.date;\n                fetchBefore(date);\n            }\n            fs.writeFile('latest.json', data);\n        });\n    });\n    setTimeout(fetchLatest, 10 * 60 * 1000);\n})();\nhttp.createServer(function (request, response) {\n    var url = request.url;\n    if (url == '/favicon.ico')   return;\n    var file = 'latest.json';\n    if (url.length == 16) {\n        var path = url.substr(8, 4) + '/' + url.substr(8, 8) + '.json';\n        if (fs.existsSync(path))  file = path;\n    }\n    var data = fs.readFileSync(file);\n    var json = JSON.parse(data);\n    response.writeHead(200, {'Content-Type': 'text/html;charset=utf-8'});\n    response.write('<!doctype html><html><head><title>知乎日报</title>');\n    response.write('<meta name=\"viewport\" content=\"width=device-width,user-scalable=no\" />');\n    response.write('<style>a{color:#333;text-decoration:none;}body{max-width:600px;margin:10px auto;padding:10px;}</style></head><body>');\n    response.write('<h1><a href=\"/\">知乎日报</a> - ' + json.display_date + '</h1>');\n    for (var i = 0; i < json.news.length; i++) {\n        response.write('<h3><a href=\"' + json.news[i].share_url + '\" target=\"_blank\">' + json.news[i].title + '</a></h3>');\n    }\n    response.write('<h3><a href=\"/before/' + json.date + '\"><<< 前一天</a></h3>');\n    response.write('</body></html>');\n    response.end();\n}).listen(process.env.PORT || 1337, null);最初版本\nvar http = require('http');\nvar fs = require('fs');\nvar fetchAt=null;\nfunction writeData(data, response) {\n    var json = JSON.parse(data);\n    response.writeHead(200, {'Content-Type': 'text/html;charset=utf-8'});\n    var title = '知乎日报[' + json.date + ']';\n    response.write('<style>a{color:#333;text-decoration:none;}body{width:600px;margin:30px auto 30px;}</style>');\n    response.write('<title>' + title + '</title>');\n    response.write('<body>');\n    response.write('<h1>' + title + '</h1>');\n    for (var i = 0; i < json.news.length; i++) {\n        response.write('<h3><a href=\"' + json.news[i].share_url + '\" target=\"_blank\">' + json.news[i].title + '</a></h3>');\n    }\n    response.write('</body>');\n    response.end();\n}\nfunction fetchData(response) {\n    http.get(\"http://news.at.zhihu.com/api/1.2/news/latest\", function (res) {\n        if (res.statusCode != 200) return;\n        var data = '';\n        res.setEncoding('utf8');\n        res.on('data', function (chunk) {\n            data += chunk;\n        });\n        res.on('end', function () {\n            fs.writeFile('latest.json', data);\n            fetchAt = new Date();\n            writeData(data, response);\n        });\n    }).on('error', function (e) {\n        response.write(\"Error: \" + e.message);\n    });\n}\nhttp.createServer(function (request, response) {\n    if(request.url == '/favicon.ico')   return;\n    if(fetchAt==null||(new Date()-fetchAt)/1000/60>10){\n        fetchData(response);\n        return;\n    }\n    var data=fs.readFileSync('latest.json');\n    writeData(data, response);\n}).listen(process.env.PORT || 1337, null);"},{"title":"","content":"平时爱看知乎日报，写了个最简单的 知乎日报 web版，放在了JAE(http://zhihudaily.jd-app.com)代码如下：\n\n2014.04.13更新：增加了 前一天 功能，移动设备界面适配，采用巧妙的方式规避了时间格式化问题（取消注释即可下载所有历史文件）\n\nvar http = require('http');\nvar fs = require('fs');\nvar date = '';\nfunction fetchBefore(beforeDate) {\n    http.get(\"http://news.at.zhihu.com/api/1.2/news/before/\" + beforeDate, function (res) {\n        if (res.statusCode != 200) return;\n        var data = '';\n        res.setEncoding('utf8');\n        res.on('data', function (chunk) {\n            data += chunk;\n        });\n        res.on('end', function () {\n            var year = beforeDate.substr(0, 4);\n            if (!fs.existsSync(year))    fs.mkdirSync(year);\n            fs.writeFile(year + '/' + beforeDate + '.json', data);\n            //if (beforeDate != '20130520') fetchBefore(JSON.parse(data).date);  //fetch all the history stories\n        });\n    });\n}\n(function fetchLatest() {\n    http.get(\"http://news.at.zhihu.com/api/1.2/news/latest\", function (res) {\n        if (res.statusCode != 200) return;\n        var data = '';\n        res.setEncoding('utf8');\n        res.on('data', function (chunk) {\n            data += chunk;\n        });\n        res.on('end', function () {\n            var json = JSON.parse(data);\n            if (date != json.date) {\n                date = json.date;\n                fetchBefore(date);\n            }\n            fs.writeFile('latest.json', data);\n        });\n    });\n    setTimeout(fetchLatest, 10 * 60 * 1000);\n})();\nhttp.createServer(function (request, response) {\n    var url = request.url;\n    if (url == '/favicon.ico')   return;\n    var file = 'latest.json';\n    if (url.length == 16) {\n        var path = url.substr(8, 4) + '/' + url.substr(8, 8) + '.json';\n        if (fs.existsSync(path))  file = path;\n    }\n    var data = fs.readFileSync(file);\n    var json = JSON.parse(data);\n    response.writeHead(200, {'Content-Type': 'text/html;charset=utf-8'});\n    response.write('<!doctype html><html><head><title>知乎日报</title>');\n    response.write('<meta name=\"viewport\" content=\"width=device-width,user-scalable=no\" />');\n    response.write('<style>a{color:#333;text-decoration:none;}body{max-width:600px;margin:10px auto;padding:10px;}</style></head><body>');\n    response.write('<h1><a href=\"/\">知乎日报</a> - ' + json.display_date + '</h1>');\n    for (var i = 0; i < json.news.length; i++) {\n        response.write('<h3><a href=\"' + json.news[i].share_url + '\" target=\"_blank\">' + json.news[i].title + '</a></h3>');\n    }\n    response.write('<h3><a href=\"/before/' + json.date + '\"><<< 前一天</a></h3>');\n    response.write('</body></html>');\n    response.end();\n}).listen(process.env.PORT || 1337, null);最初版本\nvar http = require('http');\nvar fs = require('fs');\nvar fetchAt=null;\nfunction writeData(data, response) {\n    var json = JSON.parse(data);\n    response.writeHead(200, {'Content-Type': 'text/html;charset=utf-8'});\n    var title = '知乎日报[' + json.date + ']';\n    response.write('<style>a{color:#333;text-decoration:none;}body{width:600px;margin:30px auto 30px;}</style>');\n    response.write('<title>' + title + '</title>');\n    response.write('<body>');\n    response.write('<h1>' + title + '</h1>');\n    for (var i = 0; i < json.news.length; i++) {\n        response.write('<h3><a href=\"' + json.news[i].share_url + '\" target=\"_blank\">' + json.news[i].title + '</a></h3>');\n    }\n    response.write('</body>');\n    response.end();\n}\nfunction fetchData(response) {\n    http.get(\"http://news.at.zhihu.com/api/1.2/news/latest\", function (res) {\n        if (res.statusCode != 200) return;\n        var data = '';\n        res.setEncoding('utf8');\n        res.on('data', function (chunk) {\n            data += chunk;\n        });\n        res.on('end', function () {\n            fs.writeFile('latest.json', data);\n            fetchAt = new Date();\n            writeData(data, response);\n        });\n    }).on('error', function (e) {\n        response.write(\"Error: \" + e.message);\n    });\n}\nhttp.createServer(function (request, response) {\n    if(request.url == '/favicon.ico')   return;\n    if(fetchAt==null||(new Date()-fetchAt)/1000/60>10){\n        fetchData(response);\n        return;\n    }\n    var data=fs.readFileSync('latest.json');\n    writeData(data, response);\n}).listen(process.env.PORT || 1337, null);"},{"title":"","content":""},{"title":"","content":""},{"title":"","content":""},{"title":"","content":"有人有吗？发我一份呗，，，好贵的说，，m15221717661@163.com谢谢啦"},{"title":"","content":"有人有吗？发我一份呗，，，好贵的说，，m15221717661@163.com谢谢啦"},{"title":"","content":"最近一个项目要实现一组RESTful的API接口，虽然从功能角度restify更为纯粹，从性能上，stackoverflow上有人测试了简单的Hello world输出，express还略胜一筹，从功能上相比restify相比express有什么优势呢？"},{"title":"","content":""},{"title":"","content":"在 node-webkit 页面里调用 Mongous 来操作数据库，update、insert 中文会乱码，但是 find 出来的中文是正常显示的。\n在命令行里纯 node 用 Mongous 插入读取中文都是正常的。\n所以的文件都是 utf-8 的，head 也是这样的 <meta charset=\"utf-8\">"},{"title":"","content":"最近一个项目要实现一组RESTful的API接口，虽然从功能角度restify更为纯粹，从性能上，stackoverflow上有人测试了简单的Hello world输出，express还略胜一筹，从功能上相比restify相比express有什么优势呢？"},{"title":"","content":""},{"title":"","content":""},{"title":"","content":"./webstorm.sh 之后就直接运行了 然后每次运行都要敲命令 该如何是好？"},{"title":"","content":""},{"title":"","content":"使用的ubuntu 64位系统，node版本是0.11.10 -prenpm 版本是1.3.15\nroot@imeitu:~# npm install --nodedir=/root/node_modules jquerynpm http GET https://registry.npmjs.org/jquerynpm http 304 https://registry.npmjs.org/jquerynpm http GET https://registry.npmjs.org/htmlparser/1.7.6npm http GET https://registry.npmjs.org/xmlhttprequestnpm http GET https://registry.npmjs.org/location/0.0.1npm http GET https://registry.npmjs.org/navigatornpm http GET https://registry.npmjs.org/contextifynpm http GET https://registry.npmjs.org/jsdomnpm http 304 https://registry.npmjs.org/location/0.0.1npm http 304 https://registry.npmjs.org/navigatornpm http 304 https://registry.npmjs.org/jsdomnpm http 304 https://registry.npmjs.org/contextifynpm http 304 https://registry.npmjs.org/xmlhttprequestnpm http 304 https://registry.npmjs.org/htmlparser/1.7.6\n\ncontextify@0.1.6 install /root/node_modules/jquery/node_modules/contextifynode-gyp rebuild\n\ngyp: /root/node_modules/common.gypi not found (cwd: /root/node_modules/jquery/node_modules/contextify) while reading includes of binding.gypgyp ERR! configure errorgyp ERR! stack Error: gyp failed with exit code: 1gyp ERR! stack at ChildProcess.onCpExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:337:16)gyp ERR! stack at ChildProcess.EventEmitter.emit (events.js:101:17)gyp ERR! stack at Process.ChildProcess._handle.onexit (child_process.js:862:12)gyp ERR! System Linux 3.8.0-29-genericgyp ERR! command \"node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"gyp ERR! cwd /root/node_modules/jquery/node_modules/contextifygyp ERR! node -v v0.11.10-pregyp ERR! node-gyp -v v0.12.1gyp ERR! not oknpm http GET https://registry.npmjs.org/cssomnpm ERR! contextify@0.1.6 install: node-gyp rebuildnpm ERR! Exit status 1npm ERR!npm ERR! Failed at the contextify@0.1.6 install script.npm ERR! This is most likely a problem with the contextify package,npm ERR! not with npm itself.npm ERR! Tell the author that this fails on your system:npm ERR! node-gyp rebuildnpm ERR! You can get their info via:npm ERR! npm owner ls contextifynpm ERR! There is likely additional logging output above.\nnpm ERR! System Linux 3.8.0-29-genericnpm ERR! command \"/usr/local/bin/node\" \"/usr/local/bin/npm\" \"install\" \"--nodedir=/root/node_modules\" \"jquery\"npm ERR! cwd /rootnpm ERR! node -v v0.11.10-prenpm ERR! npm -v 1.3.15npm ERR! code ELIFECYCLEnpm http 304 https://registry.npmjs.org/cssomnpm ERR!npm ERR! Additional logging details can be found in:npm ERR! /root/npm-debug.lognpm ERR! not ok code 0"},{"title":"","content":"使用的ubuntu 64位系统，node版本是0.11.10 -prenpm 版本是1.3.15\nroot@imeitu:~# npm install --nodedir=/root/node_modules jquerynpm http GET https://registry.npmjs.org/jquerynpm http 304 https://registry.npmjs.org/jquerynpm http GET https://registry.npmjs.org/htmlparser/1.7.6npm http GET https://registry.npmjs.org/xmlhttprequestnpm http GET https://registry.npmjs.org/location/0.0.1npm http GET https://registry.npmjs.org/navigatornpm http GET https://registry.npmjs.org/contextifynpm http GET https://registry.npmjs.org/jsdomnpm http 304 https://registry.npmjs.org/location/0.0.1npm http 304 https://registry.npmjs.org/navigatornpm http 304 https://registry.npmjs.org/jsdomnpm http 304 https://registry.npmjs.org/contextifynpm http 304 https://registry.npmjs.org/xmlhttprequestnpm http 304 https://registry.npmjs.org/htmlparser/1.7.6\n\ncontextify@0.1.6 install /root/node_modules/jquery/node_modules/contextifynode-gyp rebuild\n\ngyp: /root/node_modules/common.gypi not found (cwd: /root/node_modules/jquery/node_modules/contextify) while reading includes of binding.gypgyp ERR! configure errorgyp ERR! stack Error: gyp failed with exit code: 1gyp ERR! stack at ChildProcess.onCpExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:337:16)gyp ERR! stack at ChildProcess.EventEmitter.emit (events.js:101:17)gyp ERR! stack at Process.ChildProcess._handle.onexit (child_process.js:862:12)gyp ERR! System Linux 3.8.0-29-genericgyp ERR! command \"node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"gyp ERR! cwd /root/node_modules/jquery/node_modules/contextifygyp ERR! node -v v0.11.10-pregyp ERR! node-gyp -v v0.12.1gyp ERR! not oknpm http GET https://registry.npmjs.org/cssomnpm ERR! contextify@0.1.6 install: node-gyp rebuildnpm ERR! Exit status 1npm ERR!npm ERR! Failed at the contextify@0.1.6 install script.npm ERR! This is most likely a problem with the contextify package,npm ERR! not with npm itself.npm ERR! Tell the author that this fails on your system:npm ERR! node-gyp rebuildnpm ERR! You can get their info via:npm ERR! npm owner ls contextifynpm ERR! There is likely additional logging output above.\nnpm ERR! System Linux 3.8.0-29-genericnpm ERR! command \"/usr/local/bin/node\" \"/usr/local/bin/npm\" \"install\" \"--nodedir=/root/node_modules\" \"jquery\"npm ERR! cwd /rootnpm ERR! node -v v0.11.10-prenpm ERR! npm -v 1.3.15npm ERR! code ELIFECYCLEnpm http 304 https://registry.npmjs.org/cssomnpm ERR!npm ERR! Additional logging details can be found in:npm ERR! /root/npm-debug.lognpm ERR! not ok code 0"},{"title":"","content":"个人觉得好像是cookie没有保存，怎么办？\n\nvar request = require('request');\nvar fs = require('fs');\n\n\nvar request = request.defaults({jar: true});\n\n\n\nrequest.post('http://www.renren.com/ajaxLogin/login',{form:{email:'***',password:***'}},function (error,response,body){\n    console.log(body);\n\n    request.get({url:'http://www.renren.com/Home.do'},function (error,response,body){\n        fs.writeFileSync('body.txt', body);\n\n    })\n});\n\n\n\n在第二个request.get()方法并没有取得想要的主页内容，Home.do判断你没有登陆。。"},{"title":"","content":""},{"title":"","content":"个人觉得好像是cookie没有保存，怎么办？\n\nvar request = require('request');\nvar fs = require('fs');\n\n\nvar request = request.defaults({jar: true});\n\n\n\nrequest.post('http://www.renren.com/ajaxLogin/login',{form:{email:'***',password:***'}},function (error,response,body){\n    console.log(body);\n\n    request.get({url:'http://www.renren.com/Home.do'},function (error,response,body){\n        fs.writeFileSync('body.txt', body);\n\n    })\n});\n\n\n\n在第二个request.get()方法并没有取得想要的主页内容，Home.do判断你没有登陆。。"},{"title":"","content":"如题~"},{"title":"","content":""},{"title":"","content":""},{"title":"","content":"前言：\n随着互联网应用的兴起，web2.0时代的到来，越来越多的人，选择用REST编程来代替原来的页面渲染。REST以资源为中心的web服务，分离了展现层和服务层，让前端和后端程序员能更专注于自己擅长的领域。\nrestify让REST变得如此简单！\n文章目录：\n\n什么是REST?\nrestify介绍\nrestify安装\nrestify服务端API\nrestify客户端API\n\n请查看博客文章\nhttp://blog.fens.me/nodejs-restify/"},{"title":"","content":"前言：\n随着互联网应用的兴起，web2.0时代的到来，越来越多的人，选择用REST编程来代替原来的页面渲染。REST以资源为中心的web服务，分离了展现层和服务层，让前端和后端程序员能更专注于自己擅长的领域。\nrestify让REST变得如此简单！\n文章目录：\n\n什么是REST?\nrestify介绍\nrestify安装\nrestify服务端API\nrestify客户端API\n\n请查看博客文章\nhttp://blog.fens.me/nodejs-restify/"},{"title":"","content":""},{"title":"","content":"看大家都用express框架在做web，试验了两天，不知道是我水平有限还是为什么，总感觉express把前后端的东西耦合的有点恶心了。\n我的想法是既然node在做网络应用时候有具有一些与生俱来的优势，那么只使用node开发api是不是会更好一点呢？前台按照single page application的思路去开发，可以使用knockout ，angular，ember等mvc框架去构造 。这样是不是更好一点呢？"},{"title":"","content":"看大家都用express框架在做web，试验了两天，不知道是我水平有限还是为什么，总感觉express把前后端的东西耦合的有点恶心了。\n我的想法是既然node在做网络应用时候有具有一些与生俱来的优势，那么只使用node开发api是不是会更好一点呢？前台按照single page application的思路去开发，可以使用knockout ，angular，ember等mvc框架去构造 。这样是不是更好一点呢？"},{"title":"","content":"最近在接触sails,打算用来搞掂课程设计- -请问一下sails的model支持主键的自增吗?看了一下文档无发现啊,英语水平捉急~求大神"},{"title":"","content":"最近在接触sails,打算用来搞掂课程设计- -请问一下sails的model支持主键的自增吗?看了一下文档无发现啊,英语水平捉急~求大神"},{"title":"","content":""},{"title":"","content":"tasks\n\nasync tasks for node.js\nAsync的简化版，主要用于原理研究，测试不充分，请不要用于产品。\nEventProxy实现原理也是类似的，老赵给出了一个简化版，原理一看就明白了。\n\nDownload\n\nGitHub\nhttps://github.com/coordcn/tasks\n\nDocumentation\n\n特别要注意的是函数的定义必须使用\nfunction name(callback){}\n不要使用\nvar name = function(callback){};\n应该是由于lazy compile的原因，这样写函数会出现未定义的错误。\n\nparallel(tasks, callback) 并行任务执行\nArguments\n\n@param tasks {object} 任务\n\n  function task(callback){\n    fs.readFile(path, function(err, data){\n      if(err){\n        callback(err);\n      }else{\n        callback(null, data);\n      }\n    });\n  }\n@param callback {function} 任务全部完成后执行的回调函数\n\n  function callback(err, results){\n    if(err){\n      handle(err);\n    }else{\n      handle(results);\n    }\n  }Example\n  parallel({\n    test0:test0function,\n    test1:test1function\n  }, callback);\n\n  function test0funtion(callback){\n    fs.readFile(path0, function(err, data){\n      if(err){\n        callback(err);\n      }else{\n        callback(null, data);\n      }\n    });\n  }\n\n  function test1funtion(callback){\n    fs.readFile(path1, function(err, data){\n      if(err){\n        callback(err);\n      }else{\n        callback(null, data);\n      }\n    });\n  }\n\n  function callback(err, reuslts){\n    if(err){\n      console.log(err);;\n    }else{\n      console.log(results.test0);\n      console.log(results.test1);\n    }\n  }series(tasks, callback) 顺序任务执行\nArguments\n\n@param tasks {object} 任务\n\n  function task(callback, reuslt){\n    var path = result;\n    fs.readFile(path, function(err, data){\n      if(err){\n        callback(err);\n      }else{\n        callback(null, data);\n      }\n    });\n  }\n@param callback {function} 任务全部完成后执行的回调函数\n\n  function callback(err, result){\n    if(err){\n      handle(err);\n    }else{\n      handle(result);\n    }\n  }Example\n  series({\n    test0:test0function,\n    test1:test1function\n  }, callback);\n\n  function test0funtion(callback, results){\n    fs.readFile(path0, function(err, data){\n      if(err){\n        callback(err);\n      }else{\n        callback(null, data);\n      }\n    });\n  }\n\n  function test1funtion(callback, results){\n    var path1;\n    if(!results.test0){\n      callback('reuslts.test0 not defined');\n    }else{\n      path1 = results.test0;\n      fs.readFile(path1, function(err, data){\n        if(err){\n          callback(err);\n        }else{\n          callback(null, data);\n        }\n      });\n    }\n  };\n\n  function callback(err, reuslts){\n    if(err){\n      console.log(err);;\n    }else{\n      console.log(results.test0);\n      console.log(results.test1);\n    }\n  }"},{"title":"","content":""},{"title":"","content":"./webstorm.sh 之后就直接运行了 然后每次运行都要敲命令 该如何是好？"},{"title":"","content":"tasks\n\nasync tasks for node.js\nAsync的简化版，主要用于原理研究，测试不充分，请不要用于产品。\nEventProxy实现原理也是类似的，老赵给出了一个简化版，原理一看就明白了。\n\nDownload\n\nGitHub\nhttps://github.com/coordcn/tasks\n\nDocumentation\n\n特别要注意的是函数的定义必须使用\nfunction name(callback){}\n不要使用\nvar name = function(callback){};\n应该是由于lazy compile的原因，这样写函数会出现未定义的错误。\n\nparallel(tasks, callback) 并行任务执行\nArguments\n\n@param tasks {object} 任务\n\n  function task(callback){\n    fs.readFile(path, function(err, data){\n      if(err){\n        callback(err);\n      }else{\n        callback(null, data);\n      }\n    });\n  }\n@param callback {function} 任务全部完成后执行的回调函数\n\n  function callback(err, results){\n    if(err){\n      handle(err);\n    }else{\n      handle(results);\n    }\n  }Example\n  parallel({\n    test0:test0function,\n    test1:test1function\n  }, callback);\n\n  function test0funtion(callback){\n    fs.readFile(path0, function(err, data){\n      if(err){\n        callback(err);\n      }else{\n        callback(null, data);\n      }\n    });\n  }\n\n  function test1funtion(callback){\n    fs.readFile(path1, function(err, data){\n      if(err){\n        callback(err);\n      }else{\n        callback(null, data);\n      }\n    });\n  }\n\n  function callback(err, reuslts){\n    if(err){\n      console.log(err);;\n    }else{\n      console.log(results.test0);\n      console.log(results.test1);\n    }\n  }series(tasks, callback) 顺序任务执行\nArguments\n\n@param tasks {object} 任务\n\n  function task(callback, reuslt){\n    var path = result;\n    fs.readFile(path, function(err, data){\n      if(err){\n        callback(err);\n      }else{\n        callback(null, data);\n      }\n    });\n  }\n@param callback {function} 任务全部完成后执行的回调函数\n\n  function callback(err, result){\n    if(err){\n      handle(err);\n    }else{\n      handle(result);\n    }\n  }Example\n  series({\n    test0:test0function,\n    test1:test1function\n  }, callback);\n\n  function test0funtion(callback, results){\n    fs.readFile(path0, function(err, data){\n      if(err){\n        callback(err);\n      }else{\n        callback(null, data);\n      }\n    });\n  }\n\n  function test1funtion(callback, results){\n    var path1;\n    if(!results.test0){\n      callback('reuslts.test0 not defined');\n    }else{\n      path1 = results.test0;\n      fs.readFile(path1, function(err, data){\n        if(err){\n          callback(err);\n        }else{\n          callback(null, data);\n        }\n      });\n    }\n  };\n\n  function callback(err, reuslts){\n    if(err){\n      console.log(err);;\n    }else{\n      console.log(results.test0);\n      console.log(results.test1);\n    }\n  }"},{"title":"","content":"已经尝试了这种写法：app.set('view engine', 'ejs');app.engine('html', require('ejs').renderFile);\n和\napp.engine('.html', ejs.__express);app.set('view engine', 'html');"},{"title":"","content":"已经尝试了这种写法：app.set('view engine', 'ejs');app.engine('html', require('ejs').renderFile);\n和\napp.engine('.html', ejs.__express);app.set('view engine', 'html');"},{"title":"","content":""},{"title":"","content":"js有没有什么方法可以在调用一个对象方法之前调用一个指定函数比如 , 我想在调用a,b,c方法之前都调用一次c方法\nfunction obj(){\n    this.a = function(){\n        console.log(\"a\");\n    }\n    this.b = function(){\n        console.log(\"b\");\n    }\n    this.c = function(){\n        console.log(\"c\");\n    }\n}"},{"title":"","content":"js有没有什么方法可以在调用一个对象方法之前调用一个指定函数比如 , 我想在调用a,b,c方法之前都调用一次c方法\nfunction obj(){\n    this.a = function(){\n        console.log(\"a\");\n    }\n    this.b = function(){\n        console.log(\"b\");\n    }\n    this.c = function(){\n        console.log(\"c\");\n    }\n}"},{"title":"","content":""},{"title":"","content":""},{"title":"","content":"从刚接触Node.js到现在，自己也是一路摸滚打爬过来的，虽不说是什么高手，但对于如何学习Node.js，还是有一些个人见解，拿出来与大家共勉~ \n学习Node.js大致有 6 个步骤或者说 6 个层次：\n第一步\n对于刚接触Node.js的新手来说，第一步无非是打好基础，你需要弄明白以下事情：\n\nJavaScript 的特性和语法。假如你对 JavaScript 还不熟悉的话，推荐书籍及链接：\nJavaScript 推荐书籍列表\n深入理解JavaScript系列\n\n\nNode.js 是什么？Node.js与JavaScript的区别是什么？\nNode.js的优点？Node.js的缺点？\nNode.js适用场景？Node.js不适用的场景？\nNode.js的基本语法。Node.js的特性：\n单线程\n异步 IO\n事件驱动\n\n\nnpm 是什么？npm的基本使用\nREPL\n等等\n\n其实上面的内容，大部分Node.js的书籍都有介绍。基本了解了Node.js后，我们可以写一些 hello world 的程序：\n\n搭建一个 HTTP 服务器，返回 hello, world 。(使用 HTTP 模块)\n读取一个 txt 文件，将内容显示到命令行中。（使用 fs 模块）\n等等\n\n第二步\n你也许想，Node.js 只有那些少得可怜的核心模块能做什么呢？别担心，npm 上目前有近 7W 的第三方模块，月下载量高达 2.1亿 （2014—4—20 数据）... 这才是 Node.js 的活力所在。当你对Node.js已经了解的差不多了，并且按耐不住跃跃欲试了。这个时候，我们不妨用 Node.js 的第三方模块做些好玩的事情：\n\n搭建一个微博网站\n搭建一个博客网站\n搭建一个在线聊天室\n写一个简单的爬虫\n调用一些网站的API做一些好玩的东西\n等等\n\n但是，并不是说 Node.js 只能做以上事情，几乎其他语言能做的事情 Node.js 都能做，而且有些情况下能做的更好。\n第三步\n当然，就像学 js 也不能只会用框架一样，学习 Node.js 也不能只会用外部模块。这个时候，我们需要回头深入了解下 Node.js 核心模块的用法。说白了，就是好好看 Node.js 官方 API 文档。看文档是码农必备技能，英语不好的童鞋浏览器装个划词翻译的插件。\n第四步\n\n多实践。不管是用核心模块还是外部模块，尝试用 Node.js 解决某个问题或者替换掉以前用其他语言写过的代码。\n读源码。这里说的读源码并不是说上来就去读 Node 或者其他较大的框架的源码。这个时候，挑一些简单的只实现某个特定功能的工具模块的源码读，这种模块的代码通常在几百行，阅读起来并不是很困难，但是却能涨不少的姿势。比如：\nunderscore （学习 JavaScript 的语法和技巧）\n等等\n\n\n\n第五步\n坚持第四步。在使用 Node.js 时发现没有合适的模块选择或者选择的模块功能不尽人意，这个时候你可以尝试去创建一个模块或者修改现有的模块，并且使用 npm 发布自己的模块或者去该模块的 GitHub  上提 PR 。\n第六步\n\n多实践。这个就不用解释了\n读 Node 源码及较大的框架的源码。提高必备\n多关注下 GitHub 上的牛人\n重复第1-6步\n\nPS：贯穿始终的是买几本 Node.js 的书读，推荐《深入浅出Node.js》。"},{"title":"","content":"从刚接触Node.js到现在，自己也是一路摸滚打爬过来的，虽不说是什么高手，但对于如何学习Node.js，还是有一些个人见解，拿出来与大家共勉~ \n学习Node.js大致有 6 个步骤或者说 6 个层次：\n第一步\n对于刚接触Node.js的新手来说，第一步无非是打好基础，你需要弄明白以下事情：\n\nJavaScript 的特性和语法。假如你对 JavaScript 还不熟悉的话，推荐书籍及链接：\nJavaScript 推荐书籍列表\n深入理解JavaScript系列\n\n\nNode.js 是什么？Node.js与JavaScript的区别是什么？\nNode.js的优点？Node.js的缺点？\nNode.js适用场景？Node.js不适用的场景？\nNode.js的基本语法。Node.js的特性：\n单线程\n异步 IO\n事件驱动\n\n\nnpm 是什么？npm的基本使用\nREPL\n等等\n\n其实上面的内容，大部分Node.js的书籍都有介绍。基本了解了Node.js后，我们可以写一些 hello world 的程序：\n\n搭建一个 HTTP 服务器，返回 hello, world 。(使用 HTTP 模块)\n读取一个 txt 文件，将内容显示到命令行中。（使用 fs 模块）\n等等\n\n第二步\n你也许想，Node.js 只有那些少得可怜的核心模块能做什么呢？别担心，npm 上目前有近 7W 的第三方模块，月下载量高达 2.1亿 （2014—4—20 数据）... 这才是 Node.js 的活力所在。当你对Node.js已经了解的差不多了，并且按耐不住跃跃欲试了。这个时候，我们不妨用 Node.js 的第三方模块做些好玩的事情：\n\n搭建一个微博网站\n搭建一个博客网站\n搭建一个在线聊天室\n写一个简单的爬虫\n调用一些网站的API做一些好玩的东西\n等等\n\n但是，并不是说 Node.js 只能做以上事情，几乎其他语言能做的事情 Node.js 都能做，而且有些情况下能做的更好。\n第三步\n当然，就像学 js 也不能只会用框架一样，学习 Node.js 也不能只会用外部模块。这个时候，我们需要回头深入了解下 Node.js 核心模块的用法。说白了，就是好好看 Node.js 官方 API 文档。看文档是码农必备技能，英语不好的童鞋浏览器装个划词翻译的插件。\n第四步\n\n多实践。不管是用核心模块还是外部模块，尝试用 Node.js 解决某个问题或者替换掉以前用其他语言写过的代码。\n读源码。这里说的读源码并不是说上来就去读 Node 或者其他较大的框架的源码。这个时候，挑一些简单的只实现某个特定功能的工具模块的源码读，这种模块的代码通常在几百行，阅读起来并不是很困难，但是却能涨不少的姿势。比如：\nunderscore （学习 JavaScript 的语法和技巧）\n等等\n\n\n\n第五步\n坚持第四步。在使用 Node.js 时发现没有合适的模块选择或者选择的模块功能不尽人意，这个时候你可以尝试去创建一个模块或者修改现有的模块，并且使用 npm 发布自己的模块或者去该模块的 GitHub  上提 PR 。\n第六步\n\n多实践。这个就不用解释了\n读 Node 源码及较大的框架的源码。提高必备\n多关注下 GitHub 上的牛人\n重复第1-6步\n\nPS：贯穿始终的是买几本 Node.js 的书读，推荐《深入浅出Node.js》。"},{"title":"","content":""},{"title":"","content":"因为ubuntu自带的node版本比较低，所以从官网下载安装了最新的版本　安装到/usr/local/nodejs下面/usr/bin/node是从/usr/local/nodejs/bin／node链接过去的，用npm安装express以后，运行express提示没有命令"},{"title":"","content":"通过 nodeclub 项目源码来讲解如何做一个 nodejs + express + mongodb 项目\n\n1. About\n\n\n1.1 what:nodeclub 是 cnodejs.org 的源码，CNode 算是一个基本的博客系统，包含文章发布， 关注，评论等功能。这些功能可以说是任何一个网站的基础。从 nodeclub 里可以学到什么？\n1.基本的架构\n2.开发测试过程\n3.MVC 的设计\n4.middleware 的正确用法\n5.如何设计 Mongodb schema\n6.如何正确的使用 Mongoose\n7.如何实现一个标签系统\n8.plugins? services ?\n9.如何正确的使用 EJS helper\n10.到底该怎样写路由， restful？ \n11.如何做基本的控制验证\n12.如何发邮件\n13.session\n14.GitHub 用户登录\n15.图片上传\n16.消息发送\n\n\n\n除了 nodeclub 源码的学习笔记以外， 还会有一点最近捣鼓这一块的经验分享\n\n1.一个完整的消息订阅设计\n2.消息推送, socket + express 如何合作?\n3.包装 action\n4.蛋疼的异步回调如何处理\n\nnodeclub源码\n\n1.2 why: \n\n对于想用 nodejs  + express + mongodb 来做网站技术基础的项目， nodeclub 可以说是很好的源码级指南，当然也是我的指南，这篇文章权当做个人学习 nodeclub 的学习笔记。\n\n1.3 who\n\nwho = 一名本应该在写前端的但不知怎的一直在写后端的马脓 -> \n  @echo 'github: https://github.com/6174'\n  @echo 'weibo: http://weibo.com/u/2254313183'\n  @echo 'email: 57017125@qq.com'\n  @echo 'ps: 一直在求后端partner中，有意者联系我' \n  @send()2. nodeclub 中用到了哪些开源技术\n\n\n2.1 Node.js 项目一大优点就是有一个 package.json,  里边的 dependencies & devDependencies 可以看到这个项目所有的依赖。 对于有经验的开发者来说， 看完 package.json 基本就能知道项目的架构是怎样。 \n\n2.2 dependencies\n\n\n\nexpress: 基础框架：\nmongodb: 数据存储 \nmongoose: orm \nconnect-mongo: session （对于redis， 可以使用connect-redis）\nnodemailer：邮件 \nvalidator：验证 \npassport，passport-github： passport， \nloader: ejs-view-helper, 静态资源加载处理\n其他： event-proxy, node-markdown, ndir\n\n\n2.3 devDependencies\n\n\n测试框架：mocha, should \n运行： forever\n请求模拟: supertest\n\n\n2.4 nodeclub 以 express + mongodb + mongoose 作为基本框架, 典型的 MVC 应用\n\n\nModel: 对应mongoose orm， models目录\nview： ejs模板， views目录\ncontroler：express middleware , contollers目录 \n\n\n2.5 目录结构：\n\n- common/\n- controllers/\n- libs/\n# express中间件， 基本的auth， session 验证\n- middlewares/\n- models/\n#消息， 邮件服务\n- services/\n- plugins/\n#可以看做是对model处理的加工库\n- proxy/\n- test/\n- views/\n- app.js\n- route.js\n- config.js3. 应用入口 app.js\n\n神圣的入口文件，几乎每个项目都会有一个 entry，对于了解一个应用熟悉入口逻辑很重要。 下面将分步来看看，nodeclub 的 app.js 做了什么：\n3.1 require(./config)\n\n3.1.1 应用相关的配置的设置， 主要分为\n\n\n1.应用全局数据配置\n2.数据库连接配置\n3.session，auth 相关配置\n4.rss配置\n5.mail配置\n6.第三方连接相关配置， github， weibo\n\n配置文件也是了解应用的一个好地方， 在 config.default.js 中可以看到以下信息, 这些很可能是我们平时做应用开发的时候没有留意到的地方\n//--应用数据统计\ngoogle_tracker_id: 'UA-41753901-5',\n\n//--静态文件很可能使用cdn来做\nsite_static_host: '', // 静态文件存储域名\n\n//--求解释\nsite_enable_search_preview: false, // 开启google search preview\nsite_google_search_domain:  'cnodejs.org',  // google search preview中要搜索的域名\n\n//--运营数据\nlist_topic_count: 20,\npost_interval: 10000,\nadmins: { admin: true },\nside_ads:[]\nallow_sign_up: true,\n\n//--插件模式\nplugins: []\n3.1.2 当然这里的配置文件是 default 的，配置文件可以放在一个 config 的文件夹下面，多个文件的方式来整理。比如运营数据配置和其他数据配置分开，因为很有可能需要做一个小的工具来让非技术人员配置相关参数。这时候可以用一个 index.js 作为 facade，相当于一个大的 node module。 \n\n3.2 require('./models')\n\n3.2.1 之前已经讲了 models/ 目录对应 MVC 的 M 部分。 \n3.2.2 models/ 目录下面有 index.js, require('./models') 相当于 require('./models/index')\n\nindex 相当于一个模型的 facade, index.js 做得事情分别是\n\n1.connect mongodb \n2.require 各个 model 模块\n3.exports 所有的 model\n\n简单而言就是初始化了应用 model 层。 \n\n3.2.3 模型使用 orm 框架 mogoose 来写，了解 mogoose 过后， models 部分的代码也就是秒懂了\n\n， 我说的只是代码，literaly, 一个项目的核心就是 model 的设计，以前做过的任何项目都是一样， 数据库 table 的设计好坏直接影响应用的开发以及性能。 下面来看看各个 model 的 schema 设计(几乎直接 ctr+c, ctr+v 加上了一点点注释) :\n\n3.2.4 user\n\nvar UserSchema = new Schema({\n  //--基本用户信息， index表示在mongodb中会建立索引\n  //--unique: true 唯一性设置\n  name: { type: String, index: true },\n  loginname: { type: String, unique: true },\n  pass: { type: String },\n  email: { type: String, unique: true },\n  url: { type: String },\n  profile_image_url: {type: String},\n  location: { type: String },\n  signature: { type: String },\n  profile: { type: String },\n  weibo: { type: String },\n  avatar: { type: String },\n  githubId: { type: String, index: true },\n  githubUsername: {type: String},\n  is_block: {type: Boolean, default: false},\n\n  //--用户产生数据meta\n  score: { type: Number, default: 0 },\n  topic_count: { type: Number, default: 0 },\n  reply_count: { type: Number, default: 0 },\n  follower_count: { type: Number, default: 0 },\n  following_count: { type: Number, default: 0 },\n  collect_tag_count: { type: Number, default: 0 },\n  collect_topic_count: { type: Number, default: 0 },\n  create_at: { type: Date, default: Date.now },\n  update_at: { type: Date, default: Date.now },\n  is_star: { type: Boolean },\n  level: { type: String },\n  active: { type: Boolean, default: true },\n\n  //-mail\n  receive_reply_mail: {type: Boolean, default: false },\n  receive_at_mail: { type: Boolean, default: false },\n  from_wp: { type: Boolean },\n  retrieve_time : {type: Number},\n  retrieve_key : {type: String}\n});\n3.2.5 topic 话题\n\n//1 <- 多\n//tag <- topic <- collect  \nvar TopicSchema = new Schema({\n  title: { type: String },\n  content: { type: String },\n  author_id: { type: ObjectId },\n  top: { type: Boolean, default: false },\n  reply_count: { type: Number, default: 0 },\n  visit_count: { type: Number, default: 0 },\n  collect_count: { type: Number, default: 0 },\n  create_at: { type: Date, default: Date.now },\n  update_at: { type: Date, default: Date.now },\n  //--这里reply的设计方式不知道是否合适， 因为mongdb不同于关系型数据库，这里每次读取文章都需要重reply集合里边查找遍历一边，文章是读繁忙的。\n  //-- 一个document的大小为5Mb， 一本牛津词典的内容， 我觉得将reply放在这里应该不会有太大问题。 即便不存放reply 内容， 存放一个id数组也会好很多。\n  //-- 客官们怎么看?  \n  last_reply: { type: ObjectId },\n  last_reply_at: { type: Date, default: Date.now },\n  content_is_html: { type: Boolean }\n});\n\nvar ReplySchema = new Schema({\n  content: { type: String },\n  topic_id: { type: ObjectId, index: true },\n  author_id: { type: ObjectId },\n  reply_id : { type: ObjectId },\n  create_at: { type: Date, default: Date.now },\n  update_at: { type: Date, default: Date.now },\n  content_is_html: { type: Boolean }\n});\n\n//--话题集合\nvar TopicCollectSchema = new Schema({\n  user_id: { type: ObjectId },\n  topic_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});\n\n//--话题标签\nvar TopicTagSchema = new Schema({\n  topic_id: { type: ObjectId },\n  tag_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});\n3.2.6 tag标签系统\n\n//tag <- collect\nvar TagSchema = new Schema({\n  name: { type: String },\n  order: { type: Number, default: 1 },\n  description: { type: String },\n  background: { type: String },\n  topic_count: { type: Number, default: 0 },\n  collect_count: { type: Number, default: 0 },\n  create_at: { type: Date, default: Date.now }\n});\n\nvar TagCollectSchema = new Schema({\n  user_id: { type: ObjectId, index: true },\n  tag_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});\n3.2.7 关系 \n\nvar RelationSchema = new Schema({\n  user_id: { type: ObjectId },\n  follow_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});\n3.2.8 消息消息 model 设计， 对于一个 blog 来说， 基本的只有回复消息， 这里加了关注和@消息。 \n\n/*\n * type:\n * reply: xx 回复了你的话题\n * reply2: xx 在话题中回复了你\n * follow: xx 关注了你\n * at: xx ＠了你\n */\nvar MessageSchema = new Schema({\n  type: { type: String },\n  master_id: { type: ObjectId, index: true },\n  author_id: { type: ObjectId },\n  topic_id: { type: ObjectId },\n  reply_id: { type: ObjectId },\n  has_read: { type: Boolean, default: false },\n  create_at: { type: Date, default: Date.now }\n});3.3 require middlewares\n\n3.3.1 express 的基础是 middleware，或者说 express 的基础是 connect，connect 的基础是 middleware。middleware 模式在 professional nodejs 中有一个专门的章节来讲解。何为 middleware 呢？ middleware 模式 相当于一个加工流水线（大家叫 middleware stack），每一个 middleware 相当于一个加工步骤，当出现一个 http 请求的时候，http 请求会挨着每个 middleware 执行下去。express 里处理一个请求的过程基本上就是请求通过 middleware stack 的过程：  * -> middlewares -> 路由 -> controllers -> errorhandlering。 \n\n3.3.2 middleware 怎样做到的， 异步的方法呢？ middleware 使用 promise 的方式来处理异步，所有每个 middleware 都有三个参数 req, res, next, 对于异步的情况， 必须要调用 next() 方法。不然后续的 middleware 就无法执行。 ps: debug 的时候没调用 next() 还不会报错，一定注意\n\n3.3.3 auth.js\n\n\nauth.js exports 出来的函数全部都是中间件，从变量名就完全清楚的知道到底在做什么了\n\n//-- 需要admin权限\nexports.adminRequired = function (req, res, next) {}\n\n//-- 需要有用户\nexports.userRequired = function (req, res, next) {}\n\n//-- 需要有用户并登录\nexports.signinRequired = function (req, res, next) {\n    if (!req.session.user) {\n        res.render('notify/notify', {error: '未登入用户不能发布话题。'});\n        return;\n    }\n    next();   \n}\n\n//-- 屏蔽用户 -_-\nexports.blockUser = function (req, res, next) {}这里其实就可以看到中间件的作用了，我们以前写 php 的时候每次都需要判断用户是否登录， 没登陆 redirect 到 index.php ，只不过这里的方式是通过中间件来处理。明白这里什么意思，其他的中间件模块也就秒懂了。 \n3.4 require('./routes')\n\n3.4.1 express 的世界里另外一个很重要的就是route， Node.js 启动的是服务， 监听了某一端口， 接受 http or https or socket 请求,   那 url 中像 /index.php?blabla 这一串的存在怎么处理呢， express 的 route 功能就可以帮我们解析。 \n\n3.4.2 MVC 中如何将一个请求和 controller 联系起来呢， route 就是这样的纽带\n\n\n//--get, post 请求\napp.get('/signin', sign.showLogin);\napp.post('/signin', sign.login);\n//--使用中间件\napp.get('/signup', configMiddleware.github, passport.authenticate('github'));\napp.post('/:topic_id/reply', auth.userRequired, limit.postInterval, reply.add);\n3.4.3 route 是了解一个应用最佳的地方，一个请求如何处理， 到相应的 controller 去看就知道了。 相比起在PHP环境下配置更加灵活。当然你说你通过nginx来配置也很灵活，好吧，我们说的不是一回事。 \n\n3.5 initialization\n\n3.5.1 experess initialize: app.js 中其他大多部分就是express的初始化了， 初始化流程如下：\n\n\n1.配置上传 upload_dir\n2.模板引擎设置 \n3.express 通用中间件设置 \n4.pasport 中间件\n5.自定义中间件 \n1.auth_user\n2.block_user\n3.staticfile: upload \n4.staticfile: user_data\n\n\n6.csrf\n7.errorhandler\n8.set view cache\n\n@Note：配置的顺序很重要， 中间件的执行顺序是按照定义顺序来执行的， 如果一个中间件依赖另外的中间件， 而自己先执行了， 这种情况就会错误。 常见的问题就是session配置， 一定要记得配置 session 中间件的时候， 要先配置 cookieParser。 \n\n3.5.2 session 设置\n\n这个步骤在 initialize 里边已经有了， 不过再单独讲一下， nodeclub 使用的是 connect-mongo 来作为 session 的存储\n  //--cookieParser一定要在前面， 因为session的设置依赖cookie\n  app.use(express.cookieParser());\n  app.use(express.session({\n    secret: config.session_secret,\n    store: new MongoStore({\n      db: config.db_name,\n    }),\n  }));\n3.5.3 view helpers \n\n使用过 ejs 的肯定知道， ejs 里边 view helper 设置很简单， 就像赋值变量一样。 当对于一些通用的 helper 可以这样设置：\n    app.helpers({\n      config: config,\n      Loader: Loader,\n      assets: assets\n    });\n    app.dynamicHelpers(require('./common/render_helpers'));\n3.5.4 github pasport initialize\n\n    // github oauth\n    passport.serializeUser(function (user, done) {\n      done(null, user);\n    });\n    passport.deserializeUser(function (user, done) {\n      done(null, user);\n    });\n    passport.use(new GitHubStrategy(config.GITHUB_OAUTH, githubStrategyMiddleware));\n3.5.5 start app\n\n4. 用户注册\n\n\n4.1 user 是每个应用都会处理的基本， 注册登录登出， 看看 nodeclub 做了哪些事情：\n4.2 路由：\n\n//--设置能否直接注册， 不能的话通过github注册\nif (config.allow_sign_up) {\n  app.get('/signup', sign.showSignup);\n  app.post('/signup', sign.signup);\n} else {\n  app.get('/signup', configMiddleware.github, passport.authenticate('github'));\n}\napp.post('/signout', sign.signout);\napp.get('/signin', sign.showLogin);\napp.post('/signin', sign.login);\n4.3 controller & model：sign.signup\n\nsanitize = validator.sanitize;\ncheck = validator.check;\nexports.signup = function (req, res, next) {\n  //--xss 消毒\n  var name = sanitize(req.body.name).trim();\n  name = sanitize(name).xss();\n  ...\n  //--validations\n  try {\n    check(name, '用户名只能使用0-9，a-z，A-Z。').isAlphanumeric();\n  } catch (e) {\n    res.render('sign/signup', {error: e.message, name: name, email: email});\n    return;\n  }\n  ...\n  //--用用户名登录或者email登录\n  query = {'$or': [{'loginname': loginname}, {'email': email}]}\n  User.getUserByQuery(query, {}, function(){\n    ...\n    pass = md5(pass);\n    ...\n    User.newAndSave(name, loginname, pass, email, avatar_url, false, function (err) {\n      ...\n      // 发送激活邮件\n      mail.sendActiveMail(email, md5(email + config.session_secret), name);\n      res.render('sign/signup', {\n        success: '欢迎加入 ' + config.name + '！我们已给您的注册邮箱发送了一封邮件，请点击里面的链接来激活您的帐号。'\n      });\n    })\n  })\n}5. mongoose 的使用\n\n\n5.1 使用User.newAndSave， \n5.2 异步 callback pyramid\n\n一个应用通常会遇到这样的情景， 一个页面需要的数据包括， 文章列表， 评论列表，用户数据，广告数据， other stuff...   问题是每个都是异步的， 怎么办。 user 数据获取过后的 callback 调用文章列表获取， 文章列表获取的 callback 调用评论列表的获取... 这样就太蛋疼了。  nodeclub 使用了 eventproxy 模块优雅的解决这样的问题：\n  render = function(){}\n  var proxy = EventProxy.create('tags', 'topics', 'hot_topics', 'stars', 'tops', 'no_reply_topics', 'pages', render);\n  proxy.fail(next);\n  Tag.getAllTags(proxy.done('tags'));\n  Topic.getTopicsByQuery(query, options, proxy.done('topics'));\n  User.getUsersByQuery({ is_star: true }, { limit: 5 }, proxy.done('stars'));看完代码不言而喻。。。当然异步处理的方法有很多: \n\n1.基于事件的：eventProxy\n2.基于promise的：Async.js Q.js, when.js\n3.基于编译的：continuation, wind\n4.基于语言语法的：yield， livescript\n\n文章最后会讲一下我我的异步选择方案\n6. 消息\n\n\n6.1 原先以为有动态的消息推送， 有队列处理， 错了， 木有\n6.2 在 Sublime text 里边全局搜索 sendReply2Message 会发现是在 controller/reply.js 里边调用的， 也就是说，消息是直接触发的。 \n6.3 好吧， 这部分大概大家都能秒懂。。\n\n7. 开发\n\n7.1 测试\n\n7.1.1 一个项目必定离不开测试， nodeclub基于mocha BDD测试框架， 一切的前提假设至少能看懂jasmine或者mocha或者任何一个BDD风格的测试代码。 \n7.1.2  打开即看到app.js\n\nvar app = require('../app');\ndescribe('app.js', function () {\n  //--before， 执行it的前面会执行\n  before(function (done) {\n    //--done, 异步方法\n    app.listen(3001, done);\n  });\n  after(function () {\n    app.close();\n  });\n  it('should / status 200', function (done) {\n    //--使用 app.request()就可以模拟请求了？ 这个api哪里来的， 求解释？\n    app.request().get('/').end(function (res) {\n      res.should.status(200);\n      done();\n    });\n  });\n});\n//--按理说应该是可以正常运行了但是我一直出现这个错误:\n//--connect ADDRNOTAVAIL 知道的求解释\n//--我尝试用supertest直接测试， 但是也是一直timeout， mocha\n//--里边加大timeout时间， 结果就是一直没反应。 \n\n//--分析原因， express版本问题， nodeclub中express的版本还是2.x, 所以才会有\n//--app.request(), app.close()这些api\n//--第二个原因， 到supertest官网， 发现人家都已经转战到superagent项目了， 于是我写了下面这个测试脚本， 可以通过了\nvar express = require('express');\nvar should = require('should');\nvar path = require('path');\nvar superagent = require('superagent');\nvar app = express()\napp.get('/user', function(req, res, next) {\n    res.send(200, {\n        name: 'tobi'\n    })\n})\ndescribe('myapp.js', function() {\n    this.timeout(5000)\n    before(function(done) {\n        app.listen(21, done);\n    })\n    after(function() {\n        // app.close()\n    })\n    it('should /status 200', function(done) {\n        agent = superagent.agent()\n        agent.get('http://localhost:21/user').end(function(err, res) {\n          console.log(err, res)\n          res.should.have.status(200);\n          res.text.should.include('tobi');\n          return done();\n        });\n    })\n})7.2 运行\n\nnodejs是单线程应用， 如果我们用node命令来运行我们的应用， 当出现一个小错误， 它就挂了。 然后没有然后了。  避免这种问题的方法有如下工具：\n\n\n1.forever\n2.nodemon\n3.supervisornodeclub 使用 forever 来运行项目， 使用这类工具的好处就是， 当有代码改动过后， 会自动的重启应用。 不必每次自己去运行 node *.js\n\n8. 说说自己的经验\n\n待续...\n8.1 消息订阅设计\n8.2 express + socket\n8.3 异步\n8.4 Action"},{"title":"","content":"通过 nodeclub 项目源码来讲解如何做一个 nodejs + express + mongodb 项目\n\n1. About\n\n\n1.1 what:nodeclub 是 cnodejs.org 的源码，CNode 算是一个基本的博客系统，包含文章发布， 关注，评论等功能。这些功能可以说是任何一个网站的基础。从 nodeclub 里可以学到什么？\n1.基本的架构\n2.开发测试过程\n3.MVC 的设计\n4.middleware 的正确用法\n5.如何设计 Mongodb schema\n6.如何正确的使用 Mongoose\n7.如何实现一个标签系统\n8.plugins? services ?\n9.如何正确的使用 EJS helper\n10.到底该怎样写路由， restful？ \n11.如何做基本的控制验证\n12.如何发邮件\n13.session\n14.GitHub 用户登录\n15.图片上传\n16.消息发送\n\n\n\n除了 nodeclub 源码的学习笔记以外， 还会有一点最近捣鼓这一块的经验分享\n\n1.一个完整的消息订阅设计\n2.消息推送, socket + express 如何合作?\n3.包装 action\n4.蛋疼的异步回调如何处理\n\nnodeclub源码\n\n1.2 why: \n\n对于想用 nodejs  + express + mongodb 来做网站技术基础的项目， nodeclub 可以说是很好的源码级指南，当然也是我的指南，这篇文章权当做个人学习 nodeclub 的学习笔记。\n\n1.3 who\n\nwho = 一名本应该在写前端的但不知怎的一直在写后端的马脓 -> \n  @echo 'github: https://github.com/6174'\n  @echo 'weibo: http://weibo.com/u/2254313183'\n  @echo 'email: 57017125@qq.com'\n  @echo 'ps: 一直在求后端partner中，有意者联系我' \n  @send()2. nodeclub 中用到了哪些开源技术\n\n\n2.1 Node.js 项目一大优点就是有一个 package.json,  里边的 dependencies & devDependencies 可以看到这个项目所有的依赖。 对于有经验的开发者来说， 看完 package.json 基本就能知道项目的架构是怎样。 \n\n2.2 dependencies\n\n\n\nexpress: 基础框架：\nmongodb: 数据存储 \nmongoose: orm \nconnect-mongo: session （对于redis， 可以使用connect-redis）\nnodemailer：邮件 \nvalidator：验证 \npassport，passport-github： passport， \nloader: ejs-view-helper, 静态资源加载处理\n其他： event-proxy, node-markdown, ndir\n\n\n2.3 devDependencies\n\n\n测试框架：mocha, should \n运行： forever\n请求模拟: supertest\n\n\n2.4 nodeclub 以 express + mongodb + mongoose 作为基本框架, 典型的 MVC 应用\n\n\nModel: 对应mongoose orm， models目录\nview： ejs模板， views目录\ncontroler：express middleware , contollers目录 \n\n\n2.5 目录结构：\n\n- common/\n- controllers/\n- libs/\n# express中间件， 基本的auth， session 验证\n- middlewares/\n- models/\n#消息， 邮件服务\n- services/\n- plugins/\n#可以看做是对model处理的加工库\n- proxy/\n- test/\n- views/\n- app.js\n- route.js\n- config.js3. 应用入口 app.js\n\n神圣的入口文件，几乎每个项目都会有一个 entry，对于了解一个应用熟悉入口逻辑很重要。 下面将分步来看看，nodeclub 的 app.js 做了什么：\n3.1 require(./config)\n\n3.1.1 应用相关的配置的设置， 主要分为\n\n\n1.应用全局数据配置\n2.数据库连接配置\n3.session，auth 相关配置\n4.rss配置\n5.mail配置\n6.第三方连接相关配置， github， weibo\n\n配置文件也是了解应用的一个好地方， 在 config.default.js 中可以看到以下信息, 这些很可能是我们平时做应用开发的时候没有留意到的地方\n//--应用数据统计\ngoogle_tracker_id: 'UA-41753901-5',\n\n//--静态文件很可能使用cdn来做\nsite_static_host: '', // 静态文件存储域名\n\n//--求解释\nsite_enable_search_preview: false, // 开启google search preview\nsite_google_search_domain:  'cnodejs.org',  // google search preview中要搜索的域名\n\n//--运营数据\nlist_topic_count: 20,\npost_interval: 10000,\nadmins: { admin: true },\nside_ads:[]\nallow_sign_up: true,\n\n//--插件模式\nplugins: []\n3.1.2 当然这里的配置文件是 default 的，配置文件可以放在一个 config 的文件夹下面，多个文件的方式来整理。比如运营数据配置和其他数据配置分开，因为很有可能需要做一个小的工具来让非技术人员配置相关参数。这时候可以用一个 index.js 作为 facade，相当于一个大的 node module。 \n\n3.2 require('./models')\n\n3.2.1 之前已经讲了 models/ 目录对应 MVC 的 M 部分。 \n3.2.2 models/ 目录下面有 index.js, require('./models') 相当于 require('./models/index')\n\nindex 相当于一个模型的 facade, index.js 做得事情分别是\n\n1.connect mongodb \n2.require 各个 model 模块\n3.exports 所有的 model\n\n简单而言就是初始化了应用 model 层。 \n\n3.2.3 模型使用 orm 框架 mogoose 来写，了解 mogoose 过后， models 部分的代码也就是秒懂了\n\n， 我说的只是代码，literaly, 一个项目的核心就是 model 的设计，以前做过的任何项目都是一样， 数据库 table 的设计好坏直接影响应用的开发以及性能。 下面来看看各个 model 的 schema 设计(几乎直接 ctr+c, ctr+v 加上了一点点注释) :\n\n3.2.4 user\n\nvar UserSchema = new Schema({\n  //--基本用户信息， index表示在mongodb中会建立索引\n  //--unique: true 唯一性设置\n  name: { type: String, index: true },\n  loginname: { type: String, unique: true },\n  pass: { type: String },\n  email: { type: String, unique: true },\n  url: { type: String },\n  profile_image_url: {type: String},\n  location: { type: String },\n  signature: { type: String },\n  profile: { type: String },\n  weibo: { type: String },\n  avatar: { type: String },\n  githubId: { type: String, index: true },\n  githubUsername: {type: String},\n  is_block: {type: Boolean, default: false},\n\n  //--用户产生数据meta\n  score: { type: Number, default: 0 },\n  topic_count: { type: Number, default: 0 },\n  reply_count: { type: Number, default: 0 },\n  follower_count: { type: Number, default: 0 },\n  following_count: { type: Number, default: 0 },\n  collect_tag_count: { type: Number, default: 0 },\n  collect_topic_count: { type: Number, default: 0 },\n  create_at: { type: Date, default: Date.now },\n  update_at: { type: Date, default: Date.now },\n  is_star: { type: Boolean },\n  level: { type: String },\n  active: { type: Boolean, default: true },\n\n  //-mail\n  receive_reply_mail: {type: Boolean, default: false },\n  receive_at_mail: { type: Boolean, default: false },\n  from_wp: { type: Boolean },\n  retrieve_time : {type: Number},\n  retrieve_key : {type: String}\n});\n3.2.5 topic 话题\n\n//1 <- 多\n//tag <- topic <- collect  \nvar TopicSchema = new Schema({\n  title: { type: String },\n  content: { type: String },\n  author_id: { type: ObjectId },\n  top: { type: Boolean, default: false },\n  reply_count: { type: Number, default: 0 },\n  visit_count: { type: Number, default: 0 },\n  collect_count: { type: Number, default: 0 },\n  create_at: { type: Date, default: Date.now },\n  update_at: { type: Date, default: Date.now },\n  //--这里reply的设计方式不知道是否合适， 因为mongdb不同于关系型数据库，这里每次读取文章都需要重reply集合里边查找遍历一边，文章是读繁忙的。\n  //-- 一个document的大小为5Mb， 一本牛津词典的内容， 我觉得将reply放在这里应该不会有太大问题。 即便不存放reply 内容， 存放一个id数组也会好很多。\n  //-- 客官们怎么看?  \n  last_reply: { type: ObjectId },\n  last_reply_at: { type: Date, default: Date.now },\n  content_is_html: { type: Boolean }\n});\n\nvar ReplySchema = new Schema({\n  content: { type: String },\n  topic_id: { type: ObjectId, index: true },\n  author_id: { type: ObjectId },\n  reply_id : { type: ObjectId },\n  create_at: { type: Date, default: Date.now },\n  update_at: { type: Date, default: Date.now },\n  content_is_html: { type: Boolean }\n});\n\n//--话题集合\nvar TopicCollectSchema = new Schema({\n  user_id: { type: ObjectId },\n  topic_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});\n\n//--话题标签\nvar TopicTagSchema = new Schema({\n  topic_id: { type: ObjectId },\n  tag_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});\n3.2.6 tag标签系统\n\n//tag <- collect\nvar TagSchema = new Schema({\n  name: { type: String },\n  order: { type: Number, default: 1 },\n  description: { type: String },\n  background: { type: String },\n  topic_count: { type: Number, default: 0 },\n  collect_count: { type: Number, default: 0 },\n  create_at: { type: Date, default: Date.now }\n});\n\nvar TagCollectSchema = new Schema({\n  user_id: { type: ObjectId, index: true },\n  tag_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});\n3.2.7 关系 \n\nvar RelationSchema = new Schema({\n  user_id: { type: ObjectId },\n  follow_id: { type: ObjectId },\n  create_at: { type: Date, default: Date.now }\n});\n3.2.8 消息消息 model 设计， 对于一个 blog 来说， 基本的只有回复消息， 这里加了关注和@消息。 \n\n/*\n * type:\n * reply: xx 回复了你的话题\n * reply2: xx 在话题中回复了你\n * follow: xx 关注了你\n * at: xx ＠了你\n */\nvar MessageSchema = new Schema({\n  type: { type: String },\n  master_id: { type: ObjectId, index: true },\n  author_id: { type: ObjectId },\n  topic_id: { type: ObjectId },\n  reply_id: { type: ObjectId },\n  has_read: { type: Boolean, default: false },\n  create_at: { type: Date, default: Date.now }\n});3.3 require middlewares\n\n3.3.1 express 的基础是 middleware，或者说 express 的基础是 connect，connect 的基础是 middleware。middleware 模式在 professional nodejs 中有一个专门的章节来讲解。何为 middleware 呢？ middleware 模式 相当于一个加工流水线（大家叫 middleware stack），每一个 middleware 相当于一个加工步骤，当出现一个 http 请求的时候，http 请求会挨着每个 middleware 执行下去。express 里处理一个请求的过程基本上就是请求通过 middleware stack 的过程：  * -> middlewares -> 路由 -> controllers -> errorhandlering。 \n\n3.3.2 middleware 怎样做到的， 异步的方法呢？ middleware 使用 promise 的方式来处理异步，所有每个 middleware 都有三个参数 req, res, next, 对于异步的情况， 必须要调用 next() 方法。不然后续的 middleware 就无法执行。 ps: debug 的时候没调用 next() 还不会报错，一定注意\n\n3.3.3 auth.js\n\n\nauth.js exports 出来的函数全部都是中间件，从变量名就完全清楚的知道到底在做什么了\n\n//-- 需要admin权限\nexports.adminRequired = function (req, res, next) {}\n\n//-- 需要有用户\nexports.userRequired = function (req, res, next) {}\n\n//-- 需要有用户并登录\nexports.signinRequired = function (req, res, next) {\n    if (!req.session.user) {\n        res.render('notify/notify', {error: '未登入用户不能发布话题。'});\n        return;\n    }\n    next();   \n}\n\n//-- 屏蔽用户 -_-\nexports.blockUser = function (req, res, next) {}这里其实就可以看到中间件的作用了，我们以前写 php 的时候每次都需要判断用户是否登录， 没登陆 redirect 到 index.php ，只不过这里的方式是通过中间件来处理。明白这里什么意思，其他的中间件模块也就秒懂了。 \n3.4 require('./routes')\n\n3.4.1 express 的世界里另外一个很重要的就是route， Node.js 启动的是服务， 监听了某一端口， 接受 http or https or socket 请求,   那 url 中像 /index.php?blabla 这一串的存在怎么处理呢， express 的 route 功能就可以帮我们解析。 \n\n3.4.2 MVC 中如何将一个请求和 controller 联系起来呢， route 就是这样的纽带\n\n\n//--get, post 请求\napp.get('/signin', sign.showLogin);\napp.post('/signin', sign.login);\n//--使用中间件\napp.get('/signup', configMiddleware.github, passport.authenticate('github'));\napp.post('/:topic_id/reply', auth.userRequired, limit.postInterval, reply.add);\n3.4.3 route 是了解一个应用最佳的地方，一个请求如何处理， 到相应的 controller 去看就知道了。 相比起在PHP环境下配置更加灵活。当然你说你通过nginx来配置也很灵活，好吧，我们说的不是一回事。 \n\n3.5 initialization\n\n3.5.1 experess initialize: app.js 中其他大多部分就是express的初始化了， 初始化流程如下：\n\n\n1.配置上传 upload_dir\n2.模板引擎设置 \n3.express 通用中间件设置 \n4.pasport 中间件\n5.自定义中间件 \n1.auth_user\n2.block_user\n3.staticfile: upload \n4.staticfile: user_data\n\n\n6.csrf\n7.errorhandler\n8.set view cache\n\n@Note：配置的顺序很重要， 中间件的执行顺序是按照定义顺序来执行的， 如果一个中间件依赖另外的中间件， 而自己先执行了， 这种情况就会错误。 常见的问题就是session配置， 一定要记得配置 session 中间件的时候， 要先配置 cookieParser。 \n\n3.5.2 session 设置\n\n这个步骤在 initialize 里边已经有了， 不过再单独讲一下， nodeclub 使用的是 connect-mongo 来作为 session 的存储\n  //--cookieParser一定要在前面， 因为session的设置依赖cookie\n  app.use(express.cookieParser());\n  app.use(express.session({\n    secret: config.session_secret,\n    store: new MongoStore({\n      db: config.db_name,\n    }),\n  }));\n3.5.3 view helpers \n\n使用过 ejs 的肯定知道， ejs 里边 view helper 设置很简单， 就像赋值变量一样。 当对于一些通用的 helper 可以这样设置：\n    app.helpers({\n      config: config,\n      Loader: Loader,\n      assets: assets\n    });\n    app.dynamicHelpers(require('./common/render_helpers'));\n3.5.4 github pasport initialize\n\n    // github oauth\n    passport.serializeUser(function (user, done) {\n      done(null, user);\n    });\n    passport.deserializeUser(function (user, done) {\n      done(null, user);\n    });\n    passport.use(new GitHubStrategy(config.GITHUB_OAUTH, githubStrategyMiddleware));\n3.5.5 start app\n\n4. 用户注册\n\n\n4.1 user 是每个应用都会处理的基本， 注册登录登出， 看看 nodeclub 做了哪些事情：\n4.2 路由：\n\n//--设置能否直接注册， 不能的话通过github注册\nif (config.allow_sign_up) {\n  app.get('/signup', sign.showSignup);\n  app.post('/signup', sign.signup);\n} else {\n  app.get('/signup', configMiddleware.github, passport.authenticate('github'));\n}\napp.post('/signout', sign.signout);\napp.get('/signin', sign.showLogin);\napp.post('/signin', sign.login);\n4.3 controller & model：sign.signup\n\nsanitize = validator.sanitize;\ncheck = validator.check;\nexports.signup = function (req, res, next) {\n  //--xss 消毒\n  var name = sanitize(req.body.name).trim();\n  name = sanitize(name).xss();\n  ...\n  //--validations\n  try {\n    check(name, '用户名只能使用0-9，a-z，A-Z。').isAlphanumeric();\n  } catch (e) {\n    res.render('sign/signup', {error: e.message, name: name, email: email});\n    return;\n  }\n  ...\n  //--用用户名登录或者email登录\n  query = {'$or': [{'loginname': loginname}, {'email': email}]}\n  User.getUserByQuery(query, {}, function(){\n    ...\n    pass = md5(pass);\n    ...\n    User.newAndSave(name, loginname, pass, email, avatar_url, false, function (err) {\n      ...\n      // 发送激活邮件\n      mail.sendActiveMail(email, md5(email + config.session_secret), name);\n      res.render('sign/signup', {\n        success: '欢迎加入 ' + config.name + '！我们已给您的注册邮箱发送了一封邮件，请点击里面的链接来激活您的帐号。'\n      });\n    })\n  })\n}5. mongoose 的使用\n\n\n5.1 使用User.newAndSave， \n5.2 异步 callback pyramid\n\n一个应用通常会遇到这样的情景， 一个页面需要的数据包括， 文章列表， 评论列表，用户数据，广告数据， other stuff...   问题是每个都是异步的， 怎么办。 user 数据获取过后的 callback 调用文章列表获取， 文章列表获取的 callback 调用评论列表的获取... 这样就太蛋疼了。  nodeclub 使用了 eventproxy 模块优雅的解决这样的问题：\n  render = function(){}\n  var proxy = EventProxy.create('tags', 'topics', 'hot_topics', 'stars', 'tops', 'no_reply_topics', 'pages', render);\n  proxy.fail(next);\n  Tag.getAllTags(proxy.done('tags'));\n  Topic.getTopicsByQuery(query, options, proxy.done('topics'));\n  User.getUsersByQuery({ is_star: true }, { limit: 5 }, proxy.done('stars'));看完代码不言而喻。。。当然异步处理的方法有很多: \n\n1.基于事件的：eventProxy\n2.基于promise的：Async.js Q.js, when.js\n3.基于编译的：continuation, wind\n4.基于语言语法的：yield， livescript\n\n文章最后会讲一下我我的异步选择方案\n6. 消息\n\n\n6.1 原先以为有动态的消息推送， 有队列处理， 错了， 木有\n6.2 在 Sublime text 里边全局搜索 sendReply2Message 会发现是在 controller/reply.js 里边调用的， 也就是说，消息是直接触发的。 \n6.3 好吧， 这部分大概大家都能秒懂。。\n\n7. 开发\n\n7.1 测试\n\n7.1.1 一个项目必定离不开测试， nodeclub基于mocha BDD测试框架， 一切的前提假设至少能看懂jasmine或者mocha或者任何一个BDD风格的测试代码。 \n7.1.2  打开即看到app.js\n\nvar app = require('../app');\ndescribe('app.js', function () {\n  //--before， 执行it的前面会执行\n  before(function (done) {\n    //--done, 异步方法\n    app.listen(3001, done);\n  });\n  after(function () {\n    app.close();\n  });\n  it('should / status 200', function (done) {\n    //--使用 app.request()就可以模拟请求了？ 这个api哪里来的， 求解释？\n    app.request().get('/').end(function (res) {\n      res.should.status(200);\n      done();\n    });\n  });\n});\n//--按理说应该是可以正常运行了但是我一直出现这个错误:\n//--connect ADDRNOTAVAIL 知道的求解释\n//--我尝试用supertest直接测试， 但是也是一直timeout， mocha\n//--里边加大timeout时间， 结果就是一直没反应。 \n\n//--分析原因， express版本问题， nodeclub中express的版本还是2.x, 所以才会有\n//--app.request(), app.close()这些api\n//--第二个原因， 到supertest官网， 发现人家都已经转战到superagent项目了， 于是我写了下面这个测试脚本， 可以通过了\nvar express = require('express');\nvar should = require('should');\nvar path = require('path');\nvar superagent = require('superagent');\nvar app = express()\napp.get('/user', function(req, res, next) {\n    res.send(200, {\n        name: 'tobi'\n    })\n})\ndescribe('myapp.js', function() {\n    this.timeout(5000)\n    before(function(done) {\n        app.listen(21, done);\n    })\n    after(function() {\n        // app.close()\n    })\n    it('should /status 200', function(done) {\n        agent = superagent.agent()\n        agent.get('http://localhost:21/user').end(function(err, res) {\n          console.log(err, res)\n          res.should.have.status(200);\n          res.text.should.include('tobi');\n          return done();\n        });\n    })\n})7.2 运行\n\nnodejs是单线程应用， 如果我们用node命令来运行我们的应用， 当出现一个小错误， 它就挂了。 然后没有然后了。  避免这种问题的方法有如下工具：\n\n\n1.forever\n2.nodemon\n3.supervisornodeclub 使用 forever 来运行项目， 使用这类工具的好处就是， 当有代码改动过后， 会自动的重启应用。 不必每次自己去运行 node *.js\n\n8. 说说自己的经验\n\n待续...\n8.1 消息订阅设计\n8.2 express + socket\n8.3 异步\n8.4 Action"},{"title":"","content":"刚刚学习node,测试一下"},{"title":"","content":"前几天发过一篇帖子,对其中第二个网站感觉诟病很多，所以利用昨晚加今天早上的时间，将网站更新了一下。强烈建议使用谷歌浏览器查看，刚刚用360浏览器试了一下，4个字：惨不忍睹！"},{"title":"","content":"因为ubuntu自带的node版本比较低，所以从官网下载安装了最新的版本　安装到/usr/local/nodejs下面/usr/bin/node是从/usr/local/nodejs/bin／node链接过去的，用npm安装express以后，运行express提示没有命令"},{"title":"","content":"前几天发过一篇帖子,对其中第二个网站感觉诟病很多，所以利用昨晚加今天早上的时间，将网站更新了一下。强烈建议使用谷歌浏览器查看，刚刚用360浏览器试了一下，4个字：惨不忍睹！"},{"title":"","content":"关于Node.js\nNode.js于2009年面世，是一种事件驱动型编程语言，用Javascript 写成，是当前github里第二流行的库，用于构建可扩展性高的应用程序和网络程序，特别适合于网络服务器构建。\n<be />\n设置\n如果你的droplet已经安装了编译器和curl，大可跳过这部分。\n因为node.js安装本身同时需要一个编译器和curl，所以需要这些步骤。例外，对于下面三个命令（实际安装不需要），你需要在VPS上具有sudo权限。\n继续下一步，在开始安装任何所需组件之前，运行apt-get update。 sudo apt-get update\n更新完成后，在你的VPS上安装一个编译器。sudo apt-get install build-essential\n另外，一定要下载curl，我们需要它自行运行安装。 sudo apt-get install curl\n当那两个组件下载完成后，你就可以安装node.js了。\n安装node.js和NPM\n本人发现了下面这个描述安装node.js的最简单方法。根据其站点的内容，安装node.js有8种安装方法，如果愿意的话可以查看其他的方法。\n具体安装过程很顺畅，并单独在用户本地系统安装node.js。\n通过改变路径从~/local/bin 目录获得命令，启动echo 'export PATH=$HOME/local/bin:$PATH' >> ~/.bashrc\n继续下一步，加载bashrc文件\n. ~/.bashrc给安装创建两个新目录\nmkdir ~/local\nmkdir ~/node-latest-install转换到latest-install文件夹cd ~/node-latest-install\n运行curl得到node.js压缩包，接着进行解压。curl http://nodejs.org/dist/node-latest.tar.gz | tar xz --strip-components=1 \n完成后，继续下一步，开始安装进程，并限制本地用户。这可以保证稍后你不再需要sudo。/configure --prefix=~/local \n运行安装，但会遇到提醒：需要一会儿时间。make install \n通过curl下载node包管理器，就完成了。curl https://npmjs.org/install.sh | sh\n在全部完成后，你可以快速查看一下你的VPS上安装的是哪个版本。 node -v\nFrom: https://www.digitalocean.com/community/articles/how-to-install-an-upstream-version-of-node-js-on-ubuntu-12-04"},{"title":"","content":"关于Node.js\nNode.js于2009年面世，是一种事件驱动型编程语言，用Javascript 写成，是当前github里第二流行的库，用于构建可扩展性高的应用程序和网络程序，特别适合于网络服务器构建。\n<be />\n设置\n如果你的droplet已经安装了编译器和curl，大可跳过这部分。\n因为node.js安装本身同时需要一个编译器和curl，所以需要这些步骤。例外，对于下面三个命令（实际安装不需要），你需要在VPS上具有sudo权限。\n继续下一步，在开始安装任何所需组件之前，运行apt-get update。 sudo apt-get update\n更新完成后，在你的VPS上安装一个编译器。sudo apt-get install build-essential\n另外，一定要下载curl，我们需要它自行运行安装。 sudo apt-get install curl\n当那两个组件下载完成后，你就可以安装node.js了。\n安装node.js和NPM\n本人发现了下面这个描述安装node.js的最简单方法。根据其站点的内容，安装node.js有8种安装方法，如果愿意的话可以查看其他的方法。\n具体安装过程很顺畅，并单独在用户本地系统安装node.js。\n通过改变路径从~/local/bin 目录获得命令，启动echo 'export PATH=$HOME/local/bin:$PATH' >> ~/.bashrc\n继续下一步，加载bashrc文件\n. ~/.bashrc给安装创建两个新目录\nmkdir ~/local\nmkdir ~/node-latest-install转换到latest-install文件夹cd ~/node-latest-install\n运行curl得到node.js压缩包，接着进行解压。curl http://nodejs.org/dist/node-latest.tar.gz | tar xz --strip-components=1 \n完成后，继续下一步，开始安装进程，并限制本地用户。这可以保证稍后你不再需要sudo。/configure --prefix=~/local \n运行安装，但会遇到提醒：需要一会儿时间。make install \n通过curl下载node包管理器，就完成了。curl https://npmjs.org/install.sh | sh\n在全部完成后，你可以快速查看一下你的VPS上安装的是哪个版本。 node -v\nFrom: https://www.digitalocean.com/community/articles/how-to-install-an-upstream-version-of-node-js-on-ubuntu-12-04"},{"title":"","content":""},{"title":"","content":""},{"title":"","content":""},{"title":"","content":""},{"title":"","content":"connect3.0以后不建议使用bodyParser()了，改用app.use（connect.urlencoded（））app.use（connect.json（））该嗯么配置上传文件路径呢"},{"title":"","content":"我们最近在招聘nodejs方面的人才。所以，今天有位求职者过来面试，34岁，年纪不小了，8年工作经验，看上去也是很资深的样子。于是跟他聊了一些技术话题，发现很多问题：\n\n对一些基本概念理解有太多的误差。1.1 混淆第三方包和标准库这位求职者用socket.io写了个类似webQQ的聊天工具，然后把所有的功劳都归到nodejs上面，对siocket.io是一个第三方包含混不清。1.2 混淆HTTP协议和webSocket协议导致此兄认为C/S与B/S间的差异就在于可否长连接上。\n对语言没有认真思考2.1 对js语言特性没有概念此兄在nodejs和java/C#之间的区别上不知所云。也不能详述nodejs的优劣。也就是说：我会用js编程，但不知道为什么要用js编程！\n也犯些常见性毛病3.1 拿着锤子，看什么都是钉子这对很多程序员都很类似，对自己掌握的一门技术，爱它爱得要死，干什么都用它。但这跟前一个问题很相关，如果不清楚这种工具的好处，那有时候干活儿就很笨拙，就像拿了把钳子去拧螺丝一样，虽然能勉强拧动，但那不是最合适的工具，效率会大打折扣！甚至会把螺丝拧坏。3.2 学习不够一个人工作了7、8年，如果没有对IT技术有个全面而又深刻的认识，那就很难有什么竞争力了！那些后起之秀将很快上来超越，这些后浪在知识、经验、认知、性价比、可用性等方面具备更大的优势。而对IT技术的全面认识可以从两种渠道获得：工作经验和自我学习，有时需要以行业交流来补充。\n\n工作经验跟自己所在公司有关，公司业务如果很单一，那员工技能就很难扩展。\n自我学习是不受限的，自我学习可以自由安排，挑选自己感兴趣、有价值的知识内容。\n行业交流往往是通过头脑风暴的形式进行，可以快速扩展眼界。所以，如果在20～30岁间没有经过大量阅读，广泛学习，那么后面的路就很难往下走！招聘方绝对不会因为你简历上写着10年+的工作经验就直接招聘进来。相反，他的要求会更高，因为很自然的会觉得你应该懂得更多，涉猎更广，技术更扎实，工作作风更规范。\n\n\n\n\n在这里跟大家聊这些，并不是为了批评这个人，或者展示我的高明，而是希望陈述一些IT人常见的问题，表达我对IT从业者的观点。在我读别人批评的文章时，常常会自我对照，看看是不是自己有他批评的那些问题，以便弥补。因为自己常常看不到自己身上的缺点，不交流就不知道外面的世界还很宽广。我们还在招聘，有效期至2014年7月底。如果你技术不错，可以发送简历过来。详情见：http://cnodejs.org/topic/53141c252a5b081d6c0cd6ce"},{"title":"","content":""},{"title":"","content":"connect3.0以后不建议使用bodyParser()了，改用app.use（connect.urlencoded（））app.use（connect.json（））该嗯么配置上传文件路径呢"},{"title":"","content":"我们最近在招聘nodejs方面的人才。所以，今天有位求职者过来面试，34岁，年纪不小了，8年工作经验，看上去也是很资深的样子。于是跟他聊了一些技术话题，发现很多问题：\n\n对一些基本概念理解有太多的误差。1.1 混淆第三方包和标准库这位求职者用socket.io写了个类似webQQ的聊天工具，然后把所有的功劳都归到nodejs上面，对siocket.io是一个第三方包含混不清。1.2 混淆HTTP协议和webSocket协议导致此兄认为C/S与B/S间的差异就在于可否长连接上。\n对语言没有认真思考2.1 对js语言特性没有概念此兄在nodejs和java/C#之间的区别上不知所云。也不能详述nodejs的优劣。也就是说：我会用js编程，但不知道为什么要用js编程！\n也犯些常见性毛病3.1 拿着锤子，看什么都是钉子这对很多程序员都很类似，对自己掌握的一门技术，爱它爱得要死，干什么都用它。但这跟前一个问题很相关，如果不清楚这种工具的好处，那有时候干活儿就很笨拙，就像拿了把钳子去拧螺丝一样，虽然能勉强拧动，但那不是最合适的工具，效率会大打折扣！甚至会把螺丝拧坏。3.2 学习不够一个人工作了7、8年，如果没有对IT技术有个全面而又深刻的认识，那就很难有什么竞争力了！那些后起之秀将很快上来超越，这些后浪在知识、经验、认知、性价比、可用性等方面具备更大的优势。而对IT技术的全面认识可以从两种渠道获得：工作经验和自我学习，有时需要以行业交流来补充。\n\n工作经验跟自己所在公司有关，公司业务如果很单一，那员工技能就很难扩展。\n自我学习是不受限的，自我学习可以自由安排，挑选自己感兴趣、有价值的知识内容。\n行业交流往往是通过头脑风暴的形式进行，可以快速扩展眼界。所以，如果在20～30岁间没有经过大量阅读，广泛学习，那么后面的路就很难往下走！招聘方绝对不会因为你简历上写着10年+的工作经验就直接招聘进来。相反，他的要求会更高，因为很自然的会觉得你应该懂得更多，涉猎更广，技术更扎实，工作作风更规范。\n\n\n\n\n在这里跟大家聊这些，并不是为了批评这个人，或者展示我的高明，而是希望陈述一些IT人常见的问题，表达我对IT从业者的观点。在我读别人批评的文章时，常常会自我对照，看看是不是自己有他批评的那些问题，以便弥补。因为自己常常看不到自己身上的缺点，不交流就不知道外面的世界还很宽广。我们还在招聘，有效期至2014年7月底。如果你技术不错，可以发送简历过来。详情见：http://cnodejs.org/topic/53141c252a5b081d6c0cd6ce"},{"title":"","content":""},{"title":"","content":"我们正在做一个个人价值交易平台。后端各系统对nodejs使用的比较广泛，大部分时间我们都在做开创性的工作，对于我们的服务，在没有现成可用系统的情况下，我们常常需要逢山开路，遇水架桥。因此，我们的后端要有更多高手加入。我们的条件如下：1.对javascript理解深刻，熟悉nodejs的特性;2.对Mongodb，redis，memcache熟悉;3.对TCP/IP相关的基础理论有较扎实的功底;4.熟悉各种数据结构及相关算法;5.对程序优化执行有见解;6.编程习惯良好;7.心智成熟，品格良好;\n我们能给你的：很少的历史包袱，技术上可以充分发挥你的想象空间;白手起家开创新路的成就感;初期的创业团队，带你一路尝遍路上的酸甜苦辣;已获投资人认可的项目创意，以及即将获得的融资;不能给你超过同行薪资水平的承诺，但要你有超过同行能力水平的要求;\n同时，我们也欢迎各领域的同行来交流。\n地点在北京海淀区清河桥旁翠薇百货楼上。简历请投至：qian.xiong2005#gmail.com"},{"title":"","content":"我们正在做一个个人价值交易平台。后端各系统对nodejs使用的比较广泛，大部分时间我们都在做开创性的工作，对于我们的服务，在没有现成可用系统的情况下，我们常常需要逢山开路，遇水架桥。因此，我们的后端要有更多高手加入。我们的条件如下：1.对javascript理解深刻，熟悉nodejs的特性;2.对Mongodb，redis，memcache熟悉;3.对TCP/IP相关的基础理论有较扎实的功底;4.熟悉各种数据结构及相关算法;5.对程序优化执行有见解;6.编程习惯良好;7.心智成熟，品格良好;\n我们能给你的：很少的历史包袱，技术上可以充分发挥你的想象空间;白手起家开创新路的成就感;初期的创业团队，带你一路尝遍路上的酸甜苦辣;已获投资人认可的项目创意，以及即将获得的融资;不能给你超过同行薪资水平的承诺，但要你有超过同行能力水平的要求;\n同时，我们也欢迎各领域的同行来交流。\n地点在北京海淀区清河桥旁翠薇百货楼上。简历请投至：qian.xiong2005#gmail.com"},{"title":"","content":""},{"title":"","content":"nginx配置应该怎么写location /xxx{    root /home/aaa/xxx;    proxy_pass http://127.0.0.1:8001;}\nlocation /yyy{    root /home/aaa/yyy;    proxy_pass http://127.0.0.1:8002}\n怎么取不到public里面的css等文件?\n比如 http://121.14.58.212/2014  这个站点，  后台跳转到了 http://121.14.58.212:8001/http://121.14.58.212/2014  这个站点的 css文件404 错误了 。。  \n怎么办啊，急求解决"},{"title":"","content":"nginx配置应该怎么写location /xxx{    root /home/aaa/xxx;    proxy_pass http://127.0.0.1:8001;}\nlocation /yyy{    root /home/aaa/yyy;    proxy_pass http://127.0.0.1:8002}\n怎么取不到public里面的css等文件?\n比如 http://121.14.58.212/2014  这个站点，  后台跳转到了 http://121.14.58.212:8001/http://121.14.58.212/2014  这个站点的 css文件404 错误了 。。  \n怎么办啊，急求解决"},{"title":"","content":""},{"title":"","content":"跟我一起干， javascript 全栈开发。自己做产品，运营。前期没有工资，我也是在职的，也没有工资。功成，都是一方大佬！没成，都是一起奋斗一起成长的好兄弟。已经有一位UI设计师加入。\n有创业梦想，有好技术,懂产品， 对互联网有信心有追求的欢迎加我 QQ:4141095 ， 一起努力，进步，坚持。"},{"title":"","content":"公司简介：DNSPod 建立于2006年3月，是国内最大的第三方免费 DNS 解析服务商、中国第二大域名托管商。DNSPod 拥有全球最领先的云 解析平台，致力于为各类网站提供安全稳定的 DNS 解析服务。截至2013年6月，DNSPod已经专注域名解析服务7年多，已经拥有40多万用户，为250多万域名提供服务，日请求量超过130亿次。如果你沙滩上喝着饮料写程序，又或者想挑战你自己，让自己写的程序每天有超过100亿次的访问使用量，再或者你想成为一个能独当一面的人才，DNSPod都是你最好的选择。我们脑子里正有一大堆想法等着你来一起实现！一.【 Python工程师】岗位描述：负责DNSPod Python相关项目的开发和维护职位要求：\n\n精通Python开发，有1年以上的Python系统级/平台级项目开发经验\n有良好的编码习惯，代码规范，日志健全，测试完整，考虑周全\n有较强的源码阅读、分析能力，能独立开发较大规模的系统\n熟悉常见的Python第三方模块，相关工具，能快速解决线上问题加分：\n熟悉 gevent、web.py、mongodb, redis\n英文功底好，能顺利阅读英文文档和邮件\n了解网络底层原理，熟悉socket编程\n有个人技术博客和github项目\n\n二.【WEB 前端工程师】岗位描述：与设计师、后端工程师工作在一起，实现UI和交互的开发需求，确保产品拥有优质的用户体验岗位要求：能手写 HTML/JavaScript/CSS， 熟悉 jQuery 有丰富的关于 Web 标准、易用性、浏览器端原理的经验 有一定的英文基础，能阅读英文文档和邮件 有团队协作精神。善于学习，乐于探索，不墨守成规加分：热爱了解或分享互联网前沿技术如： HTML5/CSS3/Backbone.jsa.js/CoffeeScript三.【PHP后端开发工程师】岗位描述：承担DNSPod Web后端开发工作，对进度及代码质量负责岗位要求：思路清晰、善于思考、逻辑能力强性格开朗、喜欢交流、乐于分享对互联网领域有基本的认识，有自己的博客或项目具备良好的PHP编码规范、有实际的开发经验对MySQL有基本的了解，具有设计、开发的实际经验能按需求文档进行进度安排、完成开发并能编写测试脚本有一定的英文基础，能阅读英文文档及资料加分技能：对MVC/OOP有较好的理解熟悉Zend Framework或YII框架能熟练使用Linux，有用Linux作为开发环境的实际经验熟悉MySQL，有MySQL实际的维护或优化经验有开源项目或作为某开源项目的主要参与人，使用github熟悉HTML/CSS/JavaScript，了解前端工作方式四.【人事经理】岗位描述：全面统筹规划公司的人力资源战略，组织制定公司人力资源发展的各种规划，并监督各项计划的实施岗位要求：1.本科以上学历，人力资源、管理相关专业优先.2.熟悉关于合同管理、薪金制度、保险福利待遇等方面的法律法规及政策.3.有亲和力，能够激励、沟通、和协调团队.4.有解决复杂问题的心理素质和能力.5.3年以上工作经验，2年以上人力资源或管理经验.五.【产品经理】岗位描述：\n\n了解用户需求，积极做好用户调研\n设计和优化 DNSPod 产品，独立完成整个设计过程；\n规范和撰写产品所有相关文案；\n协助开发人员和视觉设计师进行详细设计和产品实现岗位要求：\n本科（含）以上学历，3年以上电子商务或互联网相关工作经验；\n设计/工业设计/人因工程/心理学/中文等相关专业优先；\n熟悉UCD理念及方法，对用户习性有独到认识，了解技术特性和系统构架\n对交互设计过程有深入的了解，熟练运用交互流程、角色模型等交互设计方法；\n具备独立完成整个设计的能力，有成功的产品设计案例；\n具备较强的学习创新能力、数据分析能力和语言表达能力；\n有理想，对生活充满热爱和好奇，有着不凡的品味和审美。六.【网页设计】岗位描述：1、网站设计和运营维护中的设计工作；2、网站的FLASH和GIF动画设计制作；3、网站发展中涉及到的视频处理和片头动画。岗位要求：1、具有美术设计或艺术类相关专业大专或以上学历；2、具备三年以上网站设计工作经验；3、从事过大型门户或专业性网站的设计工作；4、有全面精通应用Photoshop、Flash、Illustrator、CorelDraw等软件的能力；面试通过后办理入职手续并签署劳动合同，缴纳五险一金；员工享有带薪年假、生日祝福、通讯费用补助、免费健身、旅游等 福利，并可参与丰富多彩的文体活动。根据工作表现评定待遇，有广阔的发展空间。联系我们公司网址：www.dnspod.cn/www.dnspod.com咨询电话： 0535-3389555简历专用投递邮箱: jobs@dnspod.com公司地址：烟台开发区长江路28号华新国际商务大厦1210、1211、1220室"},{"title":"","content":"跟我一起干， javascript 全栈开发。自己做产品，运营。前期没有工资，我也是在职的，也没有工资。功成，都是一方大佬！没成，都是一起奋斗一起成长的好兄弟。已经有一位UI设计师加入。\n有创业梦想，有好技术,懂产品， 对互联网有信心有追求的欢迎加我 QQ:4141095 ， 一起努力，进步，坚持。"},{"title":"","content":"公司简介：DNSPod 建立于2006年3月，是国内最大的第三方免费 DNS 解析服务商、中国第二大域名托管商。DNSPod 拥有全球最领先的云 解析平台，致力于为各类网站提供安全稳定的 DNS 解析服务。截至2013年6月，DNSPod已经专注域名解析服务7年多，已经拥有40多万用户，为250多万域名提供服务，日请求量超过130亿次。如果你沙滩上喝着饮料写程序，又或者想挑战你自己，让自己写的程序每天有超过100亿次的访问使用量，再或者你想成为一个能独当一面的人才，DNSPod都是你最好的选择。我们脑子里正有一大堆想法等着你来一起实现！一.【 Python工程师】岗位描述：负责DNSPod Python相关项目的开发和维护职位要求：\n\n精通Python开发，有1年以上的Python系统级/平台级项目开发经验\n有良好的编码习惯，代码规范，日志健全，测试完整，考虑周全\n有较强的源码阅读、分析能力，能独立开发较大规模的系统\n熟悉常见的Python第三方模块，相关工具，能快速解决线上问题加分：\n熟悉 gevent、web.py、mongodb, redis\n英文功底好，能顺利阅读英文文档和邮件\n了解网络底层原理，熟悉socket编程\n有个人技术博客和github项目\n\n二.【WEB 前端工程师】岗位描述：与设计师、后端工程师工作在一起，实现UI和交互的开发需求，确保产品拥有优质的用户体验岗位要求：能手写 HTML/JavaScript/CSS， 熟悉 jQuery 有丰富的关于 Web 标准、易用性、浏览器端原理的经验 有一定的英文基础，能阅读英文文档和邮件 有团队协作精神。善于学习，乐于探索，不墨守成规加分：热爱了解或分享互联网前沿技术如： HTML5/CSS3/Backbone.jsa.js/CoffeeScript三.【PHP后端开发工程师】岗位描述：承担DNSPod Web后端开发工作，对进度及代码质量负责岗位要求：思路清晰、善于思考、逻辑能力强性格开朗、喜欢交流、乐于分享对互联网领域有基本的认识，有自己的博客或项目具备良好的PHP编码规范、有实际的开发经验对MySQL有基本的了解，具有设计、开发的实际经验能按需求文档进行进度安排、完成开发并能编写测试脚本有一定的英文基础，能阅读英文文档及资料加分技能：对MVC/OOP有较好的理解熟悉Zend Framework或YII框架能熟练使用Linux，有用Linux作为开发环境的实际经验熟悉MySQL，有MySQL实际的维护或优化经验有开源项目或作为某开源项目的主要参与人，使用github熟悉HTML/CSS/JavaScript，了解前端工作方式四.【人事经理】岗位描述：全面统筹规划公司的人力资源战略，组织制定公司人力资源发展的各种规划，并监督各项计划的实施岗位要求：1.本科以上学历，人力资源、管理相关专业优先.2.熟悉关于合同管理、薪金制度、保险福利待遇等方面的法律法规及政策.3.有亲和力，能够激励、沟通、和协调团队.4.有解决复杂问题的心理素质和能力.5.3年以上工作经验，2年以上人力资源或管理经验.五.【产品经理】岗位描述：\n\n了解用户需求，积极做好用户调研\n设计和优化 DNSPod 产品，独立完成整个设计过程；\n规范和撰写产品所有相关文案；\n协助开发人员和视觉设计师进行详细设计和产品实现岗位要求：\n本科（含）以上学历，3年以上电子商务或互联网相关工作经验；\n设计/工业设计/人因工程/心理学/中文等相关专业优先；\n熟悉UCD理念及方法，对用户习性有独到认识，了解技术特性和系统构架\n对交互设计过程有深入的了解，熟练运用交互流程、角色模型等交互设计方法；\n具备独立完成整个设计的能力，有成功的产品设计案例；\n具备较强的学习创新能力、数据分析能力和语言表达能力；\n有理想，对生活充满热爱和好奇，有着不凡的品味和审美。六.【网页设计】岗位描述：1、网站设计和运营维护中的设计工作；2、网站的FLASH和GIF动画设计制作；3、网站发展中涉及到的视频处理和片头动画。岗位要求：1、具有美术设计或艺术类相关专业大专或以上学历；2、具备三年以上网站设计工作经验；3、从事过大型门户或专业性网站的设计工作；4、有全面精通应用Photoshop、Flash、Illustrator、CorelDraw等软件的能力；面试通过后办理入职手续并签署劳动合同，缴纳五险一金；员工享有带薪年假、生日祝福、通讯费用补助、免费健身、旅游等 福利，并可参与丰富多彩的文体活动。根据工作表现评定待遇，有广阔的发展空间。联系我们公司网址：www.dnspod.cn/www.dnspod.com咨询电话： 0535-3389555简历专用投递邮箱: jobs@dnspod.com公司地址：烟台开发区长江路28号华新国际商务大厦1210、1211、1220室"},{"title":"","content":""},{"title":"","content":""},{"title":"","content":"折腾跑在openwrt上呢~有人感兴趣么？"},{"title":"","content":"百度音乐Node版WebAPP上线鸟，经过两个多月各种挖坑填坑跌跌撞撞修整方案，终得正果抗住了每天无线端千万级PV压力，访问提速1倍+秒出哦~这是音乐前端同学对Node大规模产品化应用的首次尝试，也请大家拿起手机戳http://t.cn/aeqq4R体验Node带来访问速度上的飞跃吧"},{"title":"","content":"百度音乐Node版WebAPP上线鸟，经过两个多月各种挖坑填坑跌跌撞撞修整方案，终得正果抗住了每天无线端千万级PV压力，访问提速1倍+秒出哦~这是音乐前端同学对Node大规模产品化应用的首次尝试，也请大家拿起手机戳http://t.cn/aeqq4R体验Node带来访问速度上的飞跃吧"},{"title":"","content":""},{"title":"","content":"折腾跑在openwrt上呢~有人感兴趣么？"},{"title":"","content":""},{"title":"","content":"第一期第二期 的编程训练营已经结束了。\n第三期准备在五月初开始。\n这个月的题目是 Javascript/NodeJS。\n教学模式是以远程工作的模式来做一个项目。我当客人，你当远程工作者来满足项目需求。训练的每一天我都会提交功能需求由你来完成。同时我也会发给你博文和文档，学习代码实现的相关知识。希望对正在自学而想要有实战经验的同学们能有帮助。\n每天的工作量控制在 1~2 小时。这个训练营会强迫你写代码，已实战加快对技术的熟练度。\n这个训练营你可以体验一下远程工作。除了实现一个有技术难度的项目，你也会学到敏捷工作必备的一些技巧，比如测试，持续集成，git 流程，远程协作。\n这些经验我相信在找工作上会有所帮助。\n训练营会学到些什么？\n\n实战 NodeJS\nGithub 社交写代码。\n习惯养成。每天都加强一点点。\n和有动力的伙伴们一起学习。\n\n第三期的项目是来山寨一个轻量的 Web 框架： Express\n你会学到\n\n如何创建一个 NPM package\n如何使用 Mocha 做测试驱动开发\nExpress 和 Connect 的完整实现\nHTTP 协议相关知识\n\n如果你在那里卡住了，我和学习伙伴们都可以帮你解决问题。\n适合我吗？\n\n你有基础的 Javascript 知识\n你想要在书本以外做一些真正的项目\n\n或者\n\n你想尝试用敏捷开发的技巧提高工作效率。\n\n没有 JS 的基础的话可以参加一周的 Javascript 暖身课程。第二期有些同学没有 JS 基础但是有编程经验。会比较辛苦。\n学费多少？\n三周的课程 + 一周的暖身, 600 RMB 一人。\n因为这个训练营注重学员之间的互动，如果你找朋友一起学习的话可以有一个人 400 RMB 的优惠价 。两个人是 400+400。在这个贴子里组队的不算啊~ \n在学生的优惠价是 300 RMB 一人。\n第三期限收 30 名学员，目前已经报名 9 位学员，还有 21 个位子。\n前两期都是一天内截止报名，有兴趣的别拖延哈~\n申请退款\n假如你觉得训练营的方式不合适，或者觉得难度太高，可以在暖身课程期间申请退款。\n同时我也会尽力营造一个最好的学习氛围。如果做完课程后觉得不满意，我也愿意 100% 退款。\n怎么申请？\n发邮件给我：hayeah@gmail.com\n名额有限，申请时请回答以下的问题：\n\n你的 本名, Github, 博客 是什么？\n你是学生还是在职？\n你读了那些技术相关的书？\n你解决过最难的技术问题是什么？\n你为什么想加入训练营？\n\n你是谁？\n我叫 Howard，台湾同胞一枚。小时候随家人移民加拿大。\n在大学的时候我第一次接触 Rails，那时它刚发布 1.0 版本。大学读一半跑去一家 YCombinator 的公司做 Rails 开发。后来又去了一家叫 Versapay 加拿大做支付的公司，在那里当 tech lead。\n2010 年辞了 Versapay 的工作，成为自由工作者。 2011 年远程工作，边旅行边赚钱。我写了篇有关这个经历的博文 From The Office to Travelling The World. 那一年第一次来到了天朝。\n2012 年觉得生活太安逸，决定来中国发展，发现难度瞬间提升为 Hard。在深圳和朋友创立了 小象网，做创意纸品，婚纱相册之类的产品。现在已盈利，处稳定发展状态。\n2013 夏，搬到成都和女朋友在一起。创业阶段。\nGithub: github.com/hayeahBlog: metacircus.com\n有兴趣的话发邮件到 hayeah@gmail.com"},{"title":"","content":"第一期第二期 的编程训练营已经结束了。\n第三期准备在五月初开始。\n这个月的题目是 Javascript/NodeJS。\n教学模式是以远程工作的模式来做一个项目。我当客人，你当远程工作者来满足项目需求。训练的每一天我都会提交功能需求由你来完成。同时我也会发给你博文和文档，学习代码实现的相关知识。希望对正在自学而想要有实战经验的同学们能有帮助。\n每天的工作量控制在 1~2 小时。这个训练营会强迫你写代码，已实战加快对技术的熟练度。\n这个训练营你可以体验一下远程工作。除了实现一个有技术难度的项目，你也会学到敏捷工作必备的一些技巧，比如测试，持续集成，git 流程，远程协作。\n这些经验我相信在找工作上会有所帮助。\n训练营会学到些什么？\n\n实战 NodeJS\nGithub 社交写代码。\n习惯养成。每天都加强一点点。\n和有动力的伙伴们一起学习。\n\n第三期的项目是来山寨一个轻量的 Web 框架： Express\n你会学到\n\n如何创建一个 NPM package\n如何使用 Mocha 做测试驱动开发\nExpress 和 Connect 的完整实现\nHTTP 协议相关知识\n\n如果你在那里卡住了，我和学习伙伴们都可以帮你解决问题。\n适合我吗？\n\n你有基础的 Javascript 知识\n你想要在书本以外做一些真正的项目\n\n或者\n\n你想尝试用敏捷开发的技巧提高工作效率。\n\n没有 JS 的基础的话可以参加一周的 Javascript 暖身课程。第二期有些同学没有 JS 基础但是有编程经验。会比较辛苦。\n学费多少？\n三周的课程 + 一周的暖身, 600 RMB 一人。\n因为这个训练营注重学员之间的互动，如果你找朋友一起学习的话可以有一个人 400 RMB 的优惠价 。两个人是 400+400。在这个贴子里组队的不算啊~ \n在学生的优惠价是 300 RMB 一人。\n第三期限收 30 名学员，目前已经报名 9 位学员，还有 21 个位子。\n前两期都是一天内截止报名，有兴趣的别拖延哈~\n申请退款\n假如你觉得训练营的方式不合适，或者觉得难度太高，可以在暖身课程期间申请退款。\n同时我也会尽力营造一个最好的学习氛围。如果做完课程后觉得不满意，我也愿意 100% 退款。\n怎么申请？\n发邮件给我：hayeah@gmail.com\n名额有限，申请时请回答以下的问题：\n\n你的 本名, Github, 博客 是什么？\n你是学生还是在职？\n你读了那些技术相关的书？\n你解决过最难的技术问题是什么？\n你为什么想加入训练营？\n\n你是谁？\n我叫 Howard，台湾同胞一枚。小时候随家人移民加拿大。\n在大学的时候我第一次接触 Rails，那时它刚发布 1.0 版本。大学读一半跑去一家 YCombinator 的公司做 Rails 开发。后来又去了一家叫 Versapay 加拿大做支付的公司，在那里当 tech lead。\n2010 年辞了 Versapay 的工作，成为自由工作者。 2011 年远程工作，边旅行边赚钱。我写了篇有关这个经历的博文 From The Office to Travelling The World. 那一年第一次来到了天朝。\n2012 年觉得生活太安逸，决定来中国发展，发现难度瞬间提升为 Hard。在深圳和朋友创立了 小象网，做创意纸品，婚纱相册之类的产品。现在已盈利，处稳定发展状态。\n2013 夏，搬到成都和女朋友在一起。创业阶段。\nGithub: github.com/hayeahBlog: metacircus.com\n有兴趣的话发邮件到 hayeah@gmail.com"},{"title":"","content":"最早的移植版是从这里看到的    http://laurentdesegur.wordpress.com/2011/10/22/node-js-for-android-committed/但这个是0.4的版本，后来自己移植了0.6的版本，完成后发现0.8.又出了，变化较大。其实porting早就完成了。一直没共享，现在大家可以在    https://github.com/zhentao-huang/node4android找到。至于这个有什么用，见仁见智吧\nps. 这个node.有点其它的有意思的料。"},{"title":"","content":"1.http://218.244.151.201/2.http://218.244.151.201:1337/建议使用谷歌浏览器打开。建站的起因都是源自于自己平时的需要。第一个网站可以快速下载想要的资源（下载采用弹窗模式，下载时浏览器可能会禁用，请允许）第二个网站可以快速发送restful风格的请求。"},{"title":"","content":"最早的移植版是从这里看到的    http://laurentdesegur.wordpress.com/2011/10/22/node-js-for-android-committed/但这个是0.4的版本，后来自己移植了0.6的版本，完成后发现0.8.又出了，变化较大。其实porting早就完成了。一直没共享，现在大家可以在    https://github.com/zhentao-huang/node4android找到。至于这个有什么用，见仁见智吧\nps. 这个node.有点其它的有意思的料。"},{"title":"","content":"1.http://218.244.151.201/2.http://218.244.151.201:1337/建议使用谷歌浏览器打开。建站的起因都是源自于自己平时的需要。第一个网站可以快速下载想要的资源（下载采用弹窗模式，下载时浏览器可能会禁用，请允许）第二个网站可以快速发送restful风格的请求。"},{"title":"","content":""},{"title":"","content":"简介\nNode.js是优秀的用于搭建可扩展服务器应用程序的平台，其中的一些应用程序需要与已存在的网络服务进行交互。只要这些服务是基于Rest，就不会成为问题—因为Rest服务在node世界里是最高级公民。如果需要使用一个soap网络服务， google一下node-soap，或者自己动手做一个soap信封。真正的挑战是当node需要使用soap服务时，它用的是WS-*标准（WS-安全标准，MTOM等等）。几个月前，当我面对这一情况时，没能找到任何模块帮忙。这就是我决定建Ws.js的原因。\n\n使用代码\n1,首先你需要安装Ws.js模块： npm install ws.js\n2,写代码\nvar ws = require('ws.js')\n  , Http = ws.Http\n  , Security = ws.Security\n  , UsernameToken = ws.UsernameToken\n\nvar request =  '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\">' +\n                  '<Header />' +\n                    '<Body>' +\n                      '<EchoString xmlns=\"http://tempuri.org/\">' +\n                        '<s>123</s>' +\n                      '</EchoString>' +\n                    '</Body>' +\n                '</Envelope>'\n\nvar ctx =  { request: request \n           , url: \"http://service/security\"\n           , action: \"http://tempuri.org/EchoString\"\n           , contentType: \"text/xml\" \n           }\n\nvar handlers =  [ new Security({}, [new UsernameToken({username: \"yaron\", password: \"1234\"})])\n                , new Http()\n                ]\n\nws.send(handlers, ctx, function(ctx) {                    \n  console.log(\"response: \" + ctx.response);\n})我们来分析一下这个示例。下面的代码引入了相关的模块：\nvar ws = require('ws.js')\n  , Http = ws.Http\n  , Security = ws.Security\n  , UsernameToken = ws.UsernameToken下面几行定义了soap信封和一些需要的信息比如url。注意：我们需要建带外数据的soap—因为Ws.js不是soap引擎。但通常这很容易，就如同我们有一个工作的soap实例一样。\nvar request =  '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\">' +\n                  '<Header />' +\n                    '<Body>' +\n                      '<EchoString xmlns=\"http://tempuri.org/\">' +\n                        '<s>123</s>' +\n                      '</EchoString>' +\n                    '</Body>' +\n                '</Envelope>'\n\nvar ctx =  { request: request \n           , url: \"http://service/security\"\n           , action: \"http://tempuri.org/EchoString\"\n           , contentType: \"text/xml\" \n           }之后的几行是ws-*的核心。我们在请求里定义自己想要使用的协议，这个特定的请求使用ws-安全标准，并对其进行配置来发送一个象征的用户名。\nvar handlers =  [ new Security({}, [new UsernameToken({username: \"yaron\", password: \"1234\"})])\n                , new Http()\n                ]最后，这条代码发送请求（使用规定的协议）并对回复进行处理。\nws.send(handlers, ctx, function(ctx) {                    \n  console.log(\"response: \" + ctx.response);\n})最后的soap是这个样子的：\n<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:u=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" xmlns:o=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\">\n<Header>\n  <o:Security>\n    <u:Timestamp>\n      <u:Created>2012-02-26T11:03:40Z</u:Created>\n      <u:Expires>2012-02-26T11:08:40Z</u:Expires>\n    </u:Timestamp>\n    <o:UsernameToken>\n      <o:Username>yaron</o:Username>\n      <o:Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText\">1234</o:Password>\n    </o:UsernameToken>\n  </o:Security> \n</Header>\n<Body>\n  <EchoString xmlns=\"http://tempuri.org/\">\n    <s>123</s>\n  </EchoString>\n</Body>\nMTOM实例\n发送MTOM附件的过程似曾相识，只需要指定我们想要发送的文件，还有它对应的指向soap元素的路径：\n//add attachment to the soap request\nws.addAttachment(ctx, \"request\", \"//*[local-name(.)='File1']\", \n                \"me.jpg\", \"image/jpeg\")\nvar handlers =  [ new Mtom()\n                , new Http()\n                ];整个示例在这儿。\n\n支持的协议\n现在Ws.js支持以下协议：•    MTOM•    WS-Security (只是象征性用户名)•    WS-Addressing (所有版本)•    HTTP(S) \n\n在幕后\nWs.js用的是责任连锁设计模式，来调用不同的协议。这是一种可扩展模式，任何人都可以添加新的协议实现。尽管对于soap堆栈来说是一种常见模式，但在Javascript执行却有点小麻烦。关键是每个处理程序（handler）都用一个send()和一个receive()方法，发送实际上将控制传给了下一个处理程序，我们给那个处理程序一个回调方法。那个回调将会调用我们的receive()，给它传递内容和最初我们得到的回调（下游处理程序无法得到）。能看到下面的代码最好了：\nSecurityHandler.prototype.send = function(ctx, callback) {\n  var self = this\n\n  //actual logic here...\n\n  this.next.send(ctx, function(ctx) { \n    self.receive(ctx, callback)\n  })\n}\n\nSecurityHandler.prototype.receive = function(ctx, callback) {\n\n  //optionally post processing here...\n\n  callback(ctx)\n}\n\nvar s = new SecurityHandler()\ns.next = new HttpHandler()\ns.send(ctx, function(ctx) {...})像很多node app那样，Ws.js同样使用一些外部模块，特别是依靠强大的xml处理库。正如我在这儿提到的，要发现windows上基于node.js xml parser的dom不那么容易，最终我找到了xmldom和xpath.js。\n其他Ws.js使用的有名的库是node-formidable和node-bufferjs，对于mime解析会有帮助。\n\nWs.js的未来\nWs.js框架正处于成长阶段，未来的版本，我计划添加更多高级安全标准，如x.509数字签名和加密。如果你有特别请求，发邮件到我的博客。如果想提供帮助，尽管在github加入进来—这样，Ws.js会发展很快。\nBy Yaron NavehFrom:http://www.codeproject.com/Articles/373317/Ws-js-A-Ws-implementation-for-Node-js"},{"title":"","content":"简介\nNode.js是优秀的用于搭建可扩展服务器应用程序的平台，其中的一些应用程序需要与已存在的网络服务进行交互。只要这些服务是基于Rest，就不会成为问题—因为Rest服务在node世界里是最高级公民。如果需要使用一个soap网络服务， google一下node-soap，或者自己动手做一个soap信封。真正的挑战是当node需要使用soap服务时，它用的是WS-*标准（WS-安全标准，MTOM等等）。几个月前，当我面对这一情况时，没能找到任何模块帮忙。这就是我决定建Ws.js的原因。\n\n使用代码\n1,首先你需要安装Ws.js模块： npm install ws.js\n2,写代码\nvar ws = require('ws.js')\n  , Http = ws.Http\n  , Security = ws.Security\n  , UsernameToken = ws.UsernameToken\n\nvar request =  '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\">' +\n                  '<Header />' +\n                    '<Body>' +\n                      '<EchoString xmlns=\"http://tempuri.org/\">' +\n                        '<s>123</s>' +\n                      '</EchoString>' +\n                    '</Body>' +\n                '</Envelope>'\n\nvar ctx =  { request: request \n           , url: \"http://service/security\"\n           , action: \"http://tempuri.org/EchoString\"\n           , contentType: \"text/xml\" \n           }\n\nvar handlers =  [ new Security({}, [new UsernameToken({username: \"yaron\", password: \"1234\"})])\n                , new Http()\n                ]\n\nws.send(handlers, ctx, function(ctx) {                    \n  console.log(\"response: \" + ctx.response);\n})我们来分析一下这个示例。下面的代码引入了相关的模块：\nvar ws = require('ws.js')\n  , Http = ws.Http\n  , Security = ws.Security\n  , UsernameToken = ws.UsernameToken下面几行定义了soap信封和一些需要的信息比如url。注意：我们需要建带外数据的soap—因为Ws.js不是soap引擎。但通常这很容易，就如同我们有一个工作的soap实例一样。\nvar request =  '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\">' +\n                  '<Header />' +\n                    '<Body>' +\n                      '<EchoString xmlns=\"http://tempuri.org/\">' +\n                        '<s>123</s>' +\n                      '</EchoString>' +\n                    '</Body>' +\n                '</Envelope>'\n\nvar ctx =  { request: request \n           , url: \"http://service/security\"\n           , action: \"http://tempuri.org/EchoString\"\n           , contentType: \"text/xml\" \n           }之后的几行是ws-*的核心。我们在请求里定义自己想要使用的协议，这个特定的请求使用ws-安全标准，并对其进行配置来发送一个象征的用户名。\nvar handlers =  [ new Security({}, [new UsernameToken({username: \"yaron\", password: \"1234\"})])\n                , new Http()\n                ]最后，这条代码发送请求（使用规定的协议）并对回复进行处理。\nws.send(handlers, ctx, function(ctx) {                    \n  console.log(\"response: \" + ctx.response);\n})最后的soap是这个样子的：\n<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:u=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" xmlns:o=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\">\n<Header>\n  <o:Security>\n    <u:Timestamp>\n      <u:Created>2012-02-26T11:03:40Z</u:Created>\n      <u:Expires>2012-02-26T11:08:40Z</u:Expires>\n    </u:Timestamp>\n    <o:UsernameToken>\n      <o:Username>yaron</o:Username>\n      <o:Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText\">1234</o:Password>\n    </o:UsernameToken>\n  </o:Security> \n</Header>\n<Body>\n  <EchoString xmlns=\"http://tempuri.org/\">\n    <s>123</s>\n  </EchoString>\n</Body>\nMTOM实例\n发送MTOM附件的过程似曾相识，只需要指定我们想要发送的文件，还有它对应的指向soap元素的路径：\n//add attachment to the soap request\nws.addAttachment(ctx, \"request\", \"//*[local-name(.)='File1']\", \n                \"me.jpg\", \"image/jpeg\")\nvar handlers =  [ new Mtom()\n                , new Http()\n                ];整个示例在这儿。\n\n支持的协议\n现在Ws.js支持以下协议：•    MTOM•    WS-Security (只是象征性用户名)•    WS-Addressing (所有版本)•    HTTP(S) \n\n在幕后\nWs.js用的是责任连锁设计模式，来调用不同的协议。这是一种可扩展模式，任何人都可以添加新的协议实现。尽管对于soap堆栈来说是一种常见模式，但在Javascript执行却有点小麻烦。关键是每个处理程序（handler）都用一个send()和一个receive()方法，发送实际上将控制传给了下一个处理程序，我们给那个处理程序一个回调方法。那个回调将会调用我们的receive()，给它传递内容和最初我们得到的回调（下游处理程序无法得到）。能看到下面的代码最好了：\nSecurityHandler.prototype.send = function(ctx, callback) {\n  var self = this\n\n  //actual logic here...\n\n  this.next.send(ctx, function(ctx) { \n    self.receive(ctx, callback)\n  })\n}\n\nSecurityHandler.prototype.receive = function(ctx, callback) {\n\n  //optionally post processing here...\n\n  callback(ctx)\n}\n\nvar s = new SecurityHandler()\ns.next = new HttpHandler()\ns.send(ctx, function(ctx) {...})像很多node app那样，Ws.js同样使用一些外部模块，特别是依靠强大的xml处理库。正如我在这儿提到的，要发现windows上基于node.js xml parser的dom不那么容易，最终我找到了xmldom和xpath.js。\n其他Ws.js使用的有名的库是node-formidable和node-bufferjs，对于mime解析会有帮助。\n\nWs.js的未来\nWs.js框架正处于成长阶段，未来的版本，我计划添加更多高级安全标准，如x.509数字签名和加密。如果你有特别请求，发邮件到我的博客。如果想提供帮助，尽管在github加入进来—这样，Ws.js会发展很快。\nBy Yaron NavehFrom:http://www.codeproject.com/Articles/373317/Ws-js-A-Ws-implementation-for-Node-js"},{"title":"","content":""}]